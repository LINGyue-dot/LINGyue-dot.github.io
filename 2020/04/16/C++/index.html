<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>C++ | The yundingzhishang&#39;s blog | 谢谢你这么关照我</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#77DDFF">
    
    
    <meta name="keywords" content="C++">
    <meta name="description" content="C++基础语言标识符：即变量名，函数名，宏名等 存储类型：auto（默认不写） extern static A类内函数：B类名 &amp; 函数名 {}   意思是返回值是B类的引用 &amp;&amp; 右值引用 ：即将消亡的值 &amp; 左值引用 被继承已有类：基类（父类） 派生出的新类称为派生类（子类） 对象成员：A类对象作为B类成员时，A类对象称为对象成员 最远派生类：建立对象所指定的类">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="www.yundingzhishang.xyz/2020/04/16/C++/index.html">
<meta property="og:site_name" content="The yundingzhishang&#39;s blog">
<meta property="og:description" content="C++基础语言标识符：即变量名，函数名，宏名等 存储类型：auto（默认不写） extern static A类内函数：B类名 &amp; 函数名 {}   意思是返回值是B类的引用 &amp;&amp; 右值引用 ：即将消亡的值 &amp; 左值引用 被继承已有类：基类（父类） 派生出的新类称为派生类（子类） 对象成员：A类对象作为B类成员时，A类对象称为对象成员 最远派生类：建立对象所指定的类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/learning">
<meta property="og:image" content="d:/learning">
<meta property="article:published_time" content="2020-04-16T09:52:54.000Z">
<meta property="article:modified_time" content="2020-06-08T09:58:11.829Z">
<meta property="article:author" content="Zcis">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/learning">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Zcis</h5>
          <a href="mailto:1635679571@qq.com" title="1635679571@qq.com" class="mail">1635679571@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/LINGyue-dot" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">C++</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">C++</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-16T09:52:54.000Z" itemprop="datePublished" class="page-time">
  2020-04-16
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">语言基础知识</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C-基础语言"><span class="post-toc-number">1.</span> <span class="post-toc-text">C++基础语言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#引用"><span class="post-toc-number">1.0.0.1.</span> <span class="post-toc-text">引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#带默认行参的函数"><span class="post-toc-number">1.0.0.2.</span> <span class="post-toc-text">带默认行参的函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#初始化列表和缺省参数值"><span class="post-toc-number">1.0.0.3.</span> <span class="post-toc-text">初始化列表和缺省参数值</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#构造函数"><span class="post-toc-number">1.0.0.4.</span> <span class="post-toc-text">构造函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#析构函数"><span class="post-toc-number">1.0.0.5.</span> <span class="post-toc-text">析构函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#块作用域、"><span class="post-toc-number">1.0.0.6.</span> <span class="post-toc-text">块作用域、</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#类作用域"><span class="post-toc-number">1.0.0.7.</span> <span class="post-toc-text">类作用域</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#重载函数"><span class="post-toc-number">1.0.0.8.</span> <span class="post-toc-text">重载函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#友元"><span class="post-toc-number">1.0.0.9.</span> <span class="post-toc-text">友元</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#在类中对数据直接初始化"><span class="post-toc-number">1.0.0.10.</span> <span class="post-toc-text">在类中对数据直接初始化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#常对象"><span class="post-toc-number">1.0.0.11.</span> <span class="post-toc-text">常对象</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#常成员函数"><span class="post-toc-number">1.0.0.12.</span> <span class="post-toc-text">常成员函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#静态成员函数"><span class="post-toc-number">1.0.0.13.</span> <span class="post-toc-text">静态成员函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#静态数据"><span class="post-toc-number">1.0.0.14.</span> <span class="post-toc-text">静态数据</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#const相关"><span class="post-toc-number">1.0.0.15.</span> <span class="post-toc-text">const相关</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#静态常数据"><span class="post-toc-number">1.0.0.16.</span> <span class="post-toc-text">静态常数据</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#常数据成员"><span class="post-toc-number">1.0.0.17.</span> <span class="post-toc-text">常数据成员</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#常引用"><span class="post-toc-number">1.0.0.18.</span> <span class="post-toc-text">常引用</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多文件结构和编译预处理"><span class="post-toc-number">2.</span> <span class="post-toc-text">多文件结构和编译预处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#c-一般组织结构"><span class="post-toc-number">2.0.0.1.</span> <span class="post-toc-text">c++一般组织结构</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#文件之间共享数据问题"><span class="post-toc-number">2.0.0.2.</span> <span class="post-toc-text">文件之间共享数据问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#外部变量（本文件的全局变量）"><span class="post-toc-number">2.0.0.3.</span> <span class="post-toc-text">外部变量（本文件的全局变量）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#外部函数"><span class="post-toc-number">2.0.0.4.</span> <span class="post-toc-text">外部函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#extern"><span class="post-toc-number">2.0.0.5.</span> <span class="post-toc-text">extern</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#匿名的命名空间"><span class="post-toc-number">2.0.0.6.</span> <span class="post-toc-text">匿名的命名空间</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#宏定义"><span class="post-toc-number">2.0.0.7.</span> <span class="post-toc-text">宏定义</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组"><span class="post-toc-number">3.</span> <span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#对象数组"><span class="post-toc-number">3.0.0.1.</span> <span class="post-toc-text">对象数组</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#指针（声明，赋值，引用）"><span class="post-toc-number">4.</span> <span class="post-toc-text">指针（声明，赋值，引用）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#指向常量的指针"><span class="post-toc-number">4.0.0.1.</span> <span class="post-toc-text">指向常量的指针</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#指针类型的常量"><span class="post-toc-number">4.0.0.2.</span> <span class="post-toc-text">指针类型的常量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#引用（并不是一个对象）"><span class="post-toc-number">4.0.0.3.</span> <span class="post-toc-text">引用（并不是一个对象）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#不合法指针"><span class="post-toc-number">4.0.0.4.</span> <span class="post-toc-text">不合法指针</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#指针是否有效"><span class="post-toc-number">4.0.0.5.</span> <span class="post-toc-text">指针是否有效</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#其他指针操作"><span class="post-toc-number">4.0.0.6.</span> <span class="post-toc-text">其他指针操作</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#指针有关的bool"><span class="post-toc-number">4.0.0.7.</span> <span class="post-toc-text">指针有关的bool</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#函数指针"><span class="post-toc-number">4.0.0.8.</span> <span class="post-toc-text">函数指针</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#对象指针"><span class="post-toc-number">4.0.0.9.</span> <span class="post-toc-text">对象指针</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#this指针"><span class="post-toc-number">4.0.0.10.</span> <span class="post-toc-text">this指针</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#指向类的非静态成员的指针（只能是公共成员）"><span class="post-toc-number">4.0.0.11.</span> <span class="post-toc-text">指向类的非静态成员的指针（只能是公共成员）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#指向静态的类成员的指针"><span class="post-toc-number">4.0.0.12.</span> <span class="post-toc-text">指向静态的类成员的指针</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#动态申请内存操作符new"><span class="post-toc-number">4.0.0.13.</span> <span class="post-toc-text">动态申请内存操作符new</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#释放内存空间操作delete运算符"><span class="post-toc-number">4.0.0.14.</span> <span class="post-toc-text">释放内存空间操作delete运算符</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#动态创建数组类型"><span class="post-toc-number">4.0.0.15.</span> <span class="post-toc-text">动态创建数组类型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vector"><span class="post-toc-number">4.0.0.16.</span> <span class="post-toc-text">vector</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#浅复制-只是针对类数据成员是动态数组类指针的时候"><span class="post-toc-number">4.0.0.17.</span> <span class="post-toc-text">浅复制 只是针对类数据成员是动态数组类指针的时候</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#深复制-只是针对类数据成员是动态数组类指针的时候"><span class="post-toc-number">4.0.0.18.</span> <span class="post-toc-text">深复制 只是针对类数据成员是动态数组类指针的时候</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#移动构造"><span class="post-toc-number">4.0.0.19.</span> <span class="post-toc-text">移动构造</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#string类对象-其实就是string数据类型（引用类型）"><span class="post-toc-number">4.0.0.20.</span> <span class="post-toc-text">string类对象 其实就是string数据类型（引用类型）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#getline-string文件"><span class="post-toc-number">4.0.0.21.</span> <span class="post-toc-text">getline  string文件</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#继承与多态"><span class="post-toc-number">5.</span> <span class="post-toc-text">继承与多态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#多态"><span class="post-toc-number">5.0.0.1.</span> <span class="post-toc-text">多态</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#继承方式"><span class="post-toc-number">5.0.0.2.</span> <span class="post-toc-text">继承方式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#多继承"><span class="post-toc-number">5.0.0.3.</span> <span class="post-toc-text">多继承</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#派生类的构造函数"><span class="post-toc-number">5.0.0.4.</span> <span class="post-toc-text">派生类的构造函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#派生类的复制构造函数"><span class="post-toc-number">5.0.0.5.</span> <span class="post-toc-text">派生类的复制构造函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#派生类的析构函数"><span class="post-toc-number">5.0.0.6.</span> <span class="post-toc-text">派生类的析构函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#访问基类被隐藏的成员（与派生类同名的函数）作用域分辨符：："><span class="post-toc-number">5.0.0.7.</span> <span class="post-toc-text">访问基类被隐藏的成员（与派生类同名的函数）作用域分辨符：：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#二义性问题"><span class="post-toc-number">5.0.0.8.</span> <span class="post-toc-text">二义性问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#虚基类"><span class="post-toc-number">5.0.0.9.</span> <span class="post-toc-text">虚基类</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#虚基类的构造函数"><span class="post-toc-number">5.0.0.10.</span> <span class="post-toc-text">虚基类的构造函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#多态的实现"><span class="post-toc-number">5.0.0.11.</span> <span class="post-toc-text">多态的实现</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#运算符重载为成员函数-lt-代码2-gt"><span class="post-toc-number">5.0.0.12.</span> <span class="post-toc-text">运算符重载为成员函数 &lt;代码2&gt;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#运算符重载为非成员函数-lt-代码3-gt"><span class="post-toc-number">5.0.0.13.</span> <span class="post-toc-text">运算符重载为非成员函数 &lt;代码3&gt;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#虚函数"><span class="post-toc-number">5.0.0.14.</span> <span class="post-toc-text">虚函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#虚析构函数"><span class="post-toc-number">5.0.0.15.</span> <span class="post-toc-text">虚析构函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#虚表"><span class="post-toc-number">5.0.0.16.</span> <span class="post-toc-text">虚表</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#抽象类-lt-代码5-gt"><span class="post-toc-number">5.0.0.17.</span> <span class="post-toc-text">抽象类&lt;代码5&gt;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#c-11-override和final"><span class="post-toc-number">5.0.0.18.</span> <span class="post-toc-text">c++11 override和final</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#模板"><span class="post-toc-number">6.</span> <span class="post-toc-text">模板</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#函数模板"><span class="post-toc-number">6.0.0.1.</span> <span class="post-toc-text">函数模板</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#类模板-例题借鉴-lt-代码6-gt"><span class="post-toc-number">6.0.0.2.</span> <span class="post-toc-text">类模板 例题借鉴&lt;代码6&gt;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#null"><span class="post-toc-number">6.0.0.3.</span> <span class="post-toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#大点的"><span class="post-toc-number">7.</span> <span class="post-toc-text">大点的</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#动态数组类-代码编号1"><span class="post-toc-number">7.0.0.1.</span> <span class="post-toc-text">动态数组类 代码编号1</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#未解决"><span class="post-toc-number">8.</span> <span class="post-toc-text">未解决</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#-1"><span class="post-toc-number">8.0.0.1.</span> <span class="post-toc-text"></span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-C++"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">C++</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-16 17:52:54" datetime="2020-04-16T09:52:54.000Z"  itemprop="datePublished">2020-04-16</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">语言基础知识</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="C-基础语言"><a href="#C-基础语言" class="headerlink" title="C++基础语言"></a>C++基础语言</h2><p>标识符：即变量名，函数名，宏名等</p>
<p>存储类型：auto（默认不写） extern static</p>
<p>A类内函数：B类名 &amp; 函数名 {}   意思是返回值是B类的引用</p>
<p>&amp;&amp; 右值引用 ：即将消亡的值</p>
<p>&amp; 左值引用</p>
<p>被继承已有类：基类（父类）</p>
<p>派生出的新类称为派生类（子类）</p>
<p>对象成员：A类对象作为B类成员时，A类对象称为对象成员</p>
<p>最远派生类：建立对象所指定的类</p>
<p>&amp;函数名：返回值是地址值，可以节约空间，而不必再创建一个临时对象赋值</p>
<p>群体：由多个数据元素组成的集合体</p>
<p>线性群体：按位置排列有序的</p>
<p>非线性群体：不按位置顺序来标识元素</p>
<p>U：前置单目运算符</p>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>和指针一致，传地址到子函数中，值可以直接被修改</p>
<h5 id="带默认行参的函数"><a href="#带默认行参的函数" class="headerlink" title="带默认行参的函数"></a>带默认行参的函数</h5><p>clock（int  x，int  y=2）</p>
<p>必须要从左往右赋值，因为参数入栈顺序是从右往左</p>
<h5 id="初始化列表和缺省参数值"><a href="#初始化列表和缺省参数值" class="headerlink" title="初始化列表和缺省参数值"></a>初始化列表和缺省参数值</h5><p>初始化列表：在函数之后冒号</p>
<p>​    clock（int x,int y): hour(x),miniute(y){}</p>
<p>缺省参数值：默认值</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>没有返回值</p>
<h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>没有返回值，如果未定义，那么就只有系统默认的空函数体的析构函数，是在对象生存期快要结束的时刻被自动调用，对象的内存空间被释放</p>
<h5 id="块作用域、"><a href="#块作用域、" class="headerlink" title="块作用域、"></a>块作用域、</h5><p>例如子函数中的形参，到大括号结束</p>
<h5 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h5><p>引用这个类的对象</p>
<p>例如在主函数中声明了myclock，那么这个主函数也是myclock的类作用域，或者某一子函数中声明引用</p>
<h5 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h5><p>函数名相同，但是形参的数量和数据类型是有一不同，且不以返回值类型进行区分。</p>
<h5 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h5><p>class A { public： friend  class B} B就可以直接访问A的private 数据</p>
<p>单向，非继承</p>
<h5 id="在类中对数据直接初始化"><a href="#在类中对数据直接初始化" class="headerlink" title="在类中对数据直接初始化"></a>在类中对数据直接初始化</h5><p>c++11中是可以的，但是初始化的值会被构造函数初始化列表的值所覆盖</p>
<h5 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h5><p>const clock myclock</p>
<p>前面或者后面有const  只能调用对象里面的常成员函数或者静态函数（本质上调用静态函数时候只是借用了常对象实质上是调用了类）</p>
<h5 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h5><p>void showtime（） const  //const只能放后面如果放前面意味着返回值是常量</p>
<p>常成员函数是只能读取同类数据成员的值而不能修改他</p>
<p>const可以用于重载，如果非const对象调用该函数时。调用没有const的重载函数</p>
<h5 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h5><p>只属于类，其余非静态成员函数（包括常成员函数）是属于对象的。</p>
<h5 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h5><p>static int count；</p>
<p>const clock ::count=0；</p>
<p>静态数据成员只能再类定义之外加以赋值</p>
<h5 id="const相关"><a href="#const相关" class="headerlink" title="const相关"></a>const相关</h5><p>普通数据：如果是int 或者 const int 的话就可以互相赋值但是const int 必须初始化</p>
<p>指针：指针类型必须要和所指的对象类型相同 例外一：const int* 指向常量的指针可以指向非常量的指针int  （指针类型的常量：int* const ）注意指向字符串的指针是不能通过指针来修改字符串的等价于 char *p= …       const char *p=…..</p>
<p>引用：const int&amp;可以引用一个非const的对象：const int &amp;  = int ，同样const int x=double （只是在c++中本质上创造一个const int temp= double ，再让x=temp，所以x实质上是引用一个临时量temp，所以x只允许是const类型，才可以跨类型“引用”）</p>
<p>所有的指向常量的指针或者是引用其实都是无法通过引用或者这个指针来修改他原本的值。const int  &amp;或者const int*</p>
<p><strong>静态的全局变量不能被其他文件共享，但是全局变量可以</strong></p>
<h5 id="静态常数据"><a href="#静态常数据" class="headerlink" title="静态常数据"></a>静态常数据</h5><p>static const int  b</p>
<p>同静态数据只能再类定义之外加以赋值，但是如果是具有int和enum类型就可以直接写，若在类中已经定义了初值，那么不能在类定义外再赋初值</p>
<h5 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h5><p>const int a或者int const  a</p>
<p>不能在类中直接赋值，只能通过构造函数并且必须在所有的构造函数中进行初始化</p>
<h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><p>类里面{int sum(const clock &amp;clock1,const clock &amp;clock2)}</p>
<p>const clock myclock(1,2),yourclock(3,4); </p>
<p>int sum(myclock,yourclock)</p>
<p>可以让myclock和yourclok避免被修改。</p>
<h2 id="多文件结构和编译预处理"><a href="#多文件结构和编译预处理" class="headerlink" title="多文件结构和编译预处理"></a>多文件结构和编译预处理</h2><h5 id="c-一般组织结构"><a href="#c-一般组织结构" class="headerlink" title="c++一般组织结构"></a>c++一般组织结构</h5><p>三个文件：</p>
<p>.h)类的定义 不需要空间的声明以及内联函数的的定义，外部变量和外部函数的引用性声明，不要给变量定义性声明（赋值）</p>
<p>.cpp)类的实现，类里面的函数的具体实现</p>
<p>.cpp)主函数只能写一个</p>
<p> 两个cpp文件都需要包含include文件，在被编译成obj文件后3个文件再连接成exe文件</p>
<h5 id="文件之间共享数据问题"><a href="#文件之间共享数据问题" class="headerlink" title="文件之间共享数据问题"></a>文件之间共享数据问题</h5><p>extern +全局变量：文件之间共享数据</p>
<p>static +全局变量：取消文件之间的共享</p>
<h5 id="外部变量（本文件的全局变量）"><a href="#外部变量（本文件的全局变量）" class="headerlink" title="外部变量（本文件的全局变量）"></a>外部变量（本文件的全局变量）</h5><p>用于声明外部变量</p>
<p>extern int  x   一般只用于声明变量，如果未赋值那么就是引用性声明，赋值就是定义性声明，但是变量只能有一处的定义性声明。如果在基本无法在函数内部对一个变量定义声明。引用式声明的作用域与原变量一致。</p>
<h5 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h5><p>在所有类外的可以加extern</p>
<h5 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h5><p>int和 extern int 的区别 </p>
<p>错误：例如 h文件中 int x 这时候是不能赋值的，然而 这时如果在cpp中int x或者int x=的话就会重定义报错</p>
<p>解决：h文件中extern int 不可赋值 ，再到cpp文件中进行赋值即可，并且 这个只占一个内存空间</p>
<p>注意编译过程是先各个文件编译再进行链接的这个extern只在链接时候起作用，在编译文件时候就只是告诉编译器这个是是一个来自其他文件的变量，虽然找不到他但是不会报错</p>
<h5 id="匿名的命名空间"><a href="#匿名的命名空间" class="headerlink" title="匿名的命名空间"></a>匿名的命名空间</h5><p>不希望被其他编译单元（一个cpp源文件）引用的函数和变量都在这</p>
<p>namespace {  int  n；</p>
<h5 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h5><p>#ifndef&lt; if not define&gt;//测试是否被宏定义过，定义过返回假</p>
<p>#define 1     //正文</p>
<p>#else  2    //如果定义过则编译2</p>
<p>#endif  //终止</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>二维数组在内存中是按行存放的</p>
<h5 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h5><p>clock   a[n]，这里每一个a 用于存放类中的所有私有数据，默认是调用构造函数进行对私有数据进行初始化，如果不想初始化赋值那么就需要定义一个默认的构造函数（不可以少）</p>
<p>例如  clock public：clock（int x=1 ,int y=2):x(x),y(y){}</p>
<p> pirvate：int x，int y.    int main(){  clock a[2]} ，那么a[0]={x= 1，y=2}     a[1] ={x= 1，y=2}  </p>
<h2 id="指针（声明，赋值，引用）"><a href="#指针（声明，赋值，引用）" class="headerlink" title="指针（声明，赋值，引用）"></a>指针（声明，赋值，引用）</h2><p>int *p=NULL     ==    int *p=0；</p>
<h5 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h5><p>const int *p=&amp;a；p可以改，但是不可以通过 *p来修改a</p>
<h5 id="指针类型的常量"><a href="#指针类型的常量" class="headerlink" title="指针类型的常量"></a>指针类型的常量</h5><p>int const *p= &amp;a ，p不可</p>
<h5 id="引用（并不是一个对象）"><a href="#引用（并不是一个对象）" class="headerlink" title="引用（并不是一个对象）"></a>引用（并不是一个对象）</h5><p>int &amp;refVal=ival     refVal是ival的另外的名字（引用必须被初始化）相当起了另外一个名字没有地址，并且<strong>类型需要一致</strong> ival也要int，并且只能绑定到对象上，不能int &amp;refVal=1；，<strong>注意指针无法指向引用</strong></p>
<h5 id="不合法指针"><a href="#不合法指针" class="headerlink" title="不合法指针"></a>不合法指针</h5><p>指向错误内存地址或野指针，即必须保证操作指针时，指针所指的对象是有效的，指针不为空。<strong>也需要类型一致</strong></p>
<h5 id="指针是否有效"><a href="#指针是否有效" class="headerlink" title="指针是否有效"></a>指针是否有效</h5><p>p==NULL，空指针就无效</p>
<h5 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h5><p>其他指针操作可以用作bool类型进行判断详情见c++primer第五版 p50，例如int*p=0；if（ p）</p>
<p>如果==，比较的是地址值，而不是变量值。</p>
<h5 id="指针有关的bool"><a href="#指针有关的bool" class="headerlink" title="指针有关的bool"></a>指针有关的bool</h5><p>int a=5;int *p= a;</p>
<p>if(p):p判断是否为空 if（*p）：判断a是否为0；</p>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><p>存储类型  类型  （*函数指针名）（形参的数据类型）</p>
<p>void （* function）（float）</p>
<p>存储类型：auto（默认不写） extern static</p>
<p>指向函数</p>
<p>void showtime（float a）</p>
<p>funciton=（&amp;）showtime；//指向函数，&amp;可写可不写+++++++++++++++++++++++++++++++++++++++++++++++</p>
<p>function（5.1）//调用函数</p>
<p>*</p>
<h5 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h5><p>类名 * 指针名</p>
<p>class  Clock  ； Clock   myclock ；   <strong>Clock  *point；point=&amp;myclock；</strong></p>
<p>运用</p>
<p>point-&gt;showtime();  or    (*point).showtime;</p>
<p>注意</p>
<p>1.每个对象初始化之后所占据的空间只是数据成员的空间，并没有函数副本，并且类在未初始化之前并没有分配空间地址，只有实例化之后才分配</p>
<p>2.必须初始化指向已经声明的对象，只可以访问类的公共成员</p>
<h5 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h5><p>默认中存在，隐含在每一个类的非静态成员函数中的特殊指针，指向所操作数的<strong>对象</strong></p>
<p>例如  在构造函数中 hour=x； 实际上 this-&gt;hour=x;</p>
<p>作用</p>
<p>指出成员函数当前所操作的数据所属的对象，对常成员函数来说，这个this指针就是指向常量的指针（常指针类型）</p>
<p>当局部和外部作用域中有同名的标志符的时候，若想让外部的标志符起作用的时候就可以用this</p>
<h5 id="指向类的非静态成员的指针（只能是公共成员）"><a href="#指向类的非静态成员的指针（只能是公共成员）" class="headerlink" title="指向类的非静态成员的指针（只能是公共成员）"></a>指向类的非静态成员的指针（只能是公共成员）</h5><p>指向公共函数：(括号)</p>
<p>​    声明：类型说明符 （类名：：*类成员指针名）（参数表）void (Clock:: *time)();</p>
<p>​    赋值：指针名=&amp;类名：：函数成员名  time=&amp;Clock::showtime</p>
<p>​    访问：对象名.*类成员指针名 或者对象指针名-&gt; *类成员指针名</p>
<p>​                (myclock. *time)();</p>
<p>指向公共数据：</p>
<p>​    声明：类型说明符 类名：：*指针名   例punlic int hour; int Clock :: *hours;</p>
<p>​    赋值：指针名=&amp;类名：：数据成员名 例 hours=&amp;Clock::hours</p>
<p>​    访问：对象名.*类成员指针名 或者对象指针名-&gt; *类成员指针名  myclock.hours</p>
<h5 id="指向静态的类成员的指针"><a href="#指向静态的类成员的指针" class="headerlink" title="指向静态的类成员的指针"></a>指向静态的类成员的指针</h5><p>指针无需特别定义，与一般指针是一致的</p>
<h5 id="动态申请内存操作符new"><a href="#动态申请内存操作符new" class="headerlink" title="动态申请内存操作符new"></a>动态申请内存操作符new</h5><p>声明：指针=new 数据类型名 T（初始化参数列表）<strong>返回指针</strong>    </p>
<p>​    例如：int *point; point=new int()括号可以不写就不初始化，如果括号内没有数据就是默认初始化为0</p>
<p>注意：如果new的是类的对象，就是调用构造函数，如果调用的是相同的默认的构造函数，还会递归地给基本数据类型和和指针类型用0赋初值，用new申请的空间必须由delete进行释放，否则会内存泄漏，而且只能进行一次</p>
<p>指向对象的指针时候：Clock *point=new Clock; delete point;</p>
<p>使用new创建对象数组或一般数组时，不能为该数组指定初始值，其初始值为默认值。</p>
<h5 id="释放内存空间操作delete运算符"><a href="#释放内存空间操作delete运算符" class="headerlink" title="释放内存空间操作delete运算符"></a>释放内存空间操作delete运算符</h5><p>声明： delete 指针名；   </p>
<p>注意：指针只能是由new操作所返回地，如果删除的是对象那么调用析构函数，但是指针本身地址还存在，指针不会被删除</p>
<h5 id="动态创建数组类型"><a href="#动态创建数组类型" class="headerlink" title="动态创建数组类型"></a>动态创建数组类型</h5><p>声明 ：new 数据类型名[长度]  例 int *point=new int[10];同样可以申请多维</p>
<p>可以在[]之后加()，但是不能写数据进去。</p>
<p>加（）：与上面new对象一致，给每个数据赋值0</p>
<p>不加（）：不对每个数据进行初始化，不赋值</p>
<p>删除: delete[]  指针名 ，如果不写[]那么就只释放首地址</p>
<p>多维：int （*point）[8] [9]=new int[7] [8] [9]可以看成7个[8] [9]</p>
<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>vector&lt;类型&gt;名称 +初始化</p>
<p>这个类型不能是引用</p>
<h5 id="浅复制-只是针对类数据成员是动态数组类指针的时候"><a href="#浅复制-只是针对类数据成员是动态数组类指针的时候" class="headerlink" title="浅复制 只是针对类数据成员是动态数组类指针的时候"></a>浅复制 只是针对类数据成员是动态数组类指针的时候</h5><p>就是直接调用默认的拷贝函数，但是这时候是生成2个指向同一内存地址的指针，所以delete时候会出错</p>
<p>Arrypoint  yourpoint（mypoint）</p>
<h5 id="深复制-只是针对类数据成员是动态数组类指针的时候"><a href="#深复制-只是针对类数据成员是动态数组类指针的时候" class="headerlink" title="深复制 只是针对类数据成员是动态数组类指针的时候"></a>深复制 只是针对类数据成员是动态数组类指针的时候</h5><p>在类写一个拷贝函数，就是再创建一个内存空间</p>
<p>Arryofpoint：：Arryofpoint（const Arryofpoint &amp; v）{size=v.size ，for（）{points【i】=v.points[i]；}}一个个 复制过去</p>
<h5 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h5><p>直接将原对象的内存转移给新对象，而复制构造是再生成一个新空间而将旧空间delete</p>
<p>构造函数参数表（Clock &amp;&amp;n）：points（n.points){  n.points=nullptr}</p>
<p>就是多了将旧指针指向空</p>
<h5 id="string类对象-其实就是string数据类型（引用类型）"><a href="#string类对象-其实就是string数据类型（引用类型）" class="headerlink" title="string类对象 其实就是string数据类型（引用类型）"></a>string类对象 其实就是string数据类型（引用类型）</h5><p>初始化必须包含string 文件</p>
<p> string（）//建立一个 长度为0的串</p>
<p>string（const char *s）用s所指的字符串常量初始化string</p>
<p>string=“  ” 同样可以进行bool  加减 运算 &gt; &lt;   !=</p>
<h5 id="getline-string文件"><a href="#getline-string文件" class="headerlink" title="getline  string文件"></a>getline  string文件</h5><p>getline（cin，s1，“结束标志符”）</p>
<h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态行为基础：基类声明虚函数，派生类声明同名函数覆盖这个虚函数 需要函数签名（函数名 参数列表 const）完全一致</p>
<h5 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h5><p>默认是私有继承</p>
<p>共有继承：</p>
<p>​    继承的访问权限：对基类的private 不可直接访问，这时基类的private继承下来已经发生变化（没有名称的类型）</p>
<p>​    访问权限：派生类的成员函数可以直接访问基类的public和protected，如果要访问基类的私有成员需要借助基类的共有函数成员，protected成员在类中本来是与private相同，当是在派生类中就变成了public，private同样不能直接访问</p>
<p>私有继承：</p>
<p>​    基类的全在私有成员中，要访问基类的私有成员，就得从派生类的函数调用基类的函数（这个基类函数是访问基类自己的私有成员）</p>
<p>保护继承：</p>
<p>​    <strong>在派生类中与public一致，在类外时候通过派生类对象不能访问基类任何成员</strong>（公有成员也无法直接访问）</p>
<h5 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h5><p>class 派生类名：继承方式 基类，继承方式 基类，继承方式 基类{ 成员 }</p>
<h5 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h5><p>派生类名：：派生类名（形参表）：基类1（参数），基类2（参数）本类成员初始化列表{//其他初始化} 执行顺序按照继承的顺序，而不是按照构造函数上一行所写的数据</p>
<h5 id="派生类的复制构造函数"><a href="#派生类的复制构造函数" class="headerlink" title="派生类的复制构造函数"></a>派生类的复制构造函数</h5><p>如果没有调用默认，先调用基类的复制构造函数再进行对新成员进行初始化</p>
<p>C：：C（const C &amp;C1）：B（c1）{     }</p>
<p>默认的构造函数是直接将值复制完毕的，如果自己写的话不能是空定义</p>
<h5 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h5><p>先调用派生类的析构后调用基类的，与构造函数顺序相反，无需显式调用</p>
<h5 id="访问基类被隐藏的成员（与派生类同名的函数）作用域分辨符：："><a href="#访问基类被隐藏的成员（与派生类同名的函数）作用域分辨符：：" class="headerlink" title="访问基类被隐藏的成员（与派生类同名的函数）作用域分辨符：："></a>访问基类被隐藏的成员（与派生类同名的函数）作用域分辨符：：</h5><p><strong>只有在相同的作用域才可以函数重载，所以当派生类中声明了与基类同名的即使参数列表不同，从基类继承的同名函数也会被隐藏</strong>，这时要访问就得要用作用域分辨符</p>
<p>可以Clocks.<strong>Clock::showtime</strong>  类名限定</p>
<p>如果想要将基类的同名函数重载，那么就得用子类中using  A:: showtime(int x)</p>
<p>例如Class Clocks: public Clock{public: using Clock::showtime(int x); void showtime(int x,int y);} </p>
<h5 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h5><p>2个基类中存在相同的函数成员，用类名限定，或者在派生类中添加同名函数再用类名限定</p>
<h5 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h5><p><strong>只有最远派生类调用</strong>，解决派生类从多个基类派生，而多个基类又存在同一基类，这时明显这个成员意义是单一的</p>
<p>必须要在一级继承的时候就添加 virtual关键词 例如2级继承爷父儿时候，必须要在这几个父继承时候添加class Clocks：virtual public Clock；</p>
<h5 id="虚基类的构造函数"><a href="#虚基类的构造函数" class="headerlink" title="虚基类的构造函数"></a>虚基类的构造函数</h5><p>必须在子类的构造函数初始化中添加爷的构造函数Clock（int x）：Grf（x）</p>
<p>调用构造函数顺序，如果有虚基类就先调用虚基类，然后按照类声明顺序</p>
<h5 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h5><p>静态绑定：绑定在编译连接阶段完成：重载，强制，和参数多态（模板类）</p>
<p>动态绑定：绑定在程序运行阶段完成：包含多态（大多虚函数实现）</p>
<h5 id="运算符重载为成员函数-lt-代码2-gt"><a href="#运算符重载为成员函数-lt-代码2-gt" class="headerlink" title="运算符重载为成员函数 &lt;代码2&gt;"></a>运算符重载为成员函数 &lt;代码2&gt;</h5><p>运算符重载的实质是函数重载，只针对同一类的对象</p>
<p>oprd1 和oprd2 <strong>都是A类</strong> ，双目运算符+ 如果要实现oprd1+oprd2 则应该在A类中添加运算符重载  oprd1.operator +（oprd2） 参数个数等于原操作数个数-1   </p>
<p>单目运算符 前置时候oprd.opeator ++()里面为空 后置oprd.opeator ++(int )这个int 没有用只是用来区分前置和后置</p>
<p>代码：在public中A operator+(const A&amp; c)const;声明 </p>
<p>类外A A::operator+(const A&amp; c)const {return A(real + c.real, image + c.image);}创建一个空对象并且返回A类的值(A类型可以返回是* this指针)</p>
<h5 id="运算符重载为非成员函数-lt-代码3-gt"><a href="#运算符重载为非成员函数-lt-代码3-gt" class="headerlink" title="运算符重载为非成员函数 &lt;代码3&gt;"></a>运算符重载为非成员函数 &lt;代码3&gt;</h5><p>当是无法被修改的类的2个对象进行运算时候，例如对cout进行输出修改不仅仅是输出int float型，变成可以输出A类的数据时候就需要把重载运算符为非成员函数，参数个数等于操作数个数</p>
<p>双目代码： 最好在类中设置为friend A operator +(const A&amp; c1, const A&amp; c2) 比较好访问数据，类外A operator +(const A&amp; c1, const A&amp; c2) 定义</p>
<p>单目代码：前置operator U （oprd）后置 operator U （oprd ，int）必须多一个没有用的int形参</p>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>本质上是原本函数定义形参时候就需要确定对象，但是虚函数告诉他等最后再确定对象，覆盖掉基类的虚同名函数</p>
<p>虚函数应该属于对象的，不内联,实现动态绑定</p>
<p>目的是爷父儿中存在同名的函数，只写一个形参是三者之一的函数来访问这个同名函数需要解决的问题&lt;代码4&gt;可以只在最老的基类中‘添加virtual，派生类中就不显式地使用virtual 声明虚函数，系统判断是否与基类虚函数名称，参数，返回值来判断，习惯都加virtual增加可读，<strong>虚函数会隐藏基类地所有同名重载函数</strong>只能通过类名访问</p>
<h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><p>与代码4基本一致，父子关系，想只通过一个带父指针参数地函数来删除一个用new出来地B *b =new C()的指针b       函数void fun（B *b）delete b ；这时只调用B类的析构函数同样得在析构函数加virtual使得BC2个的析构函数都可以调用</p>
<h5 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="D:\learning" alt="Snipaste_2020-04-09_17-31-09" title="pictureSnipaste_2020-04-09_17-31-09.png">
                </div>
                <div class="image-caption">pictureSnipaste_2020-04-09_17-31-09.png</div>
            </figure>

<p>vptr指针指向虚表，每个类中都有虚表</p>
<h5 id="抽象类-lt-代码5-gt"><a href="#抽象类-lt-代码5-gt" class="headerlink" title="抽象类&lt;代码5&gt;"></a>抽象类&lt;代码5&gt;</h5><p>带有纯虚函数（暂时无法实现的函数）的类就叫抽象类，抽象类只做基类不能有自己的对象，目的是保证让派生类（自己实现具体功能）具有要求的行为，但是类的指针是可以作为形参的</p>
<p>纯虚函数：virtual 类型 函数名（参数表）=0；</p>
<h5 id="c-11-override和final"><a href="#c-11-override和final" class="headerlink" title="c++11 override和final"></a>c++11 override和final</h5><p>override：当想通过派生类的函数去覆盖基类的虚函数，却因为函数签名不太一致例如少了const，而导致无法覆盖，这种错误往往不好找到，就在派生类需要覆盖的虚函数后面加override声明</p>
<p>例如 void show（）override</p>
<p>final：</p>
<p>不允许被继承，成员被覆盖</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="D:\learning" alt="Snipaste_2020-04-09_17-51-35" title="pictureSnipaste_2020-04-09_17-51-35.png">
                </div>
                <div class="image-caption">pictureSnipaste_2020-04-09_17-51-35.png</div>
            </figure>





<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h5 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h5><p>template &lt; class或typename  名T&gt;</p>
<p>函数（T  形参名） ： void f（T  x）；</p>
<p>函数上面必须有template&lt; &gt;</p>
<p>调用f(y)如果y为int就将T变成int类型 ，double同</p>
<h5 id="类模板-例题借鉴-lt-代码6-gt"><a href="#类模板-例题借鉴-lt-代码6-gt" class="headerlink" title="类模板 例题借鉴&lt;代码6&gt;"></a>类模板 例题借鉴&lt;代码6&gt;</h5><p>基本与函数模板一致，使用时候：类名&lt;类型&gt; 对象例如：Clock&lt; int&gt; myclock,yourclock; </p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h2 id="大点的"><a href="#大点的" class="headerlink" title="大点的"></a>大点的</h2><h5 id="动态数组类-代码编号1"><a href="#动态数组类-代码编号1" class="headerlink" title="动态数组类 代码编号1"></a>动态数组类 代码编号1</h5><p>在类的构造函数中point=new Point[size]完成对这个数组类的创建</p>
<h2 id="未解决"><a href="#未解决" class="headerlink" title="未解决"></a>未解决</h2><p>静态数据常数据 静态常数据   是否类内可以赋值，以及赋值关系</p>
<p>#define 放在双目计算的中间</p>
<p>闰年计算 清华c++p17</p>
<p>代码6</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-06-08T09:58:11.829Z" itemprop="dateUpdated">2020-06-08 17:58:11</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="www.yundingzhishang.xyz">
            <img src="/img/avatar.jpg" alt="Zcis">
            Zcis
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.yundingzhishang.xyz/2020/04/16/C++/&title=《C++》 — The yundingzhishang's blog&pic=www.yundingzhishang.xyz/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.yundingzhishang.xyz/2020/04/16/C++/&title=《C++》 — The yundingzhishang's blog&source=平凡，平静，前进" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=www.yundingzhishang.xyz/2020/04/16/C++/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++》 — The yundingzhishang's blog&url=www.yundingzhishang.xyz/2020/04/16/C++/&via=www.yundingzhishang.xyz" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=www.yundingzhishang.xyz/2020/04/16/C++/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/04/16/C-%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9F%9F/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">C++代码区域</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/04/15/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-Pop-Sequence/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">线性结构4 Pop Sequence</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Zcis &copy; 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.yundingzhishang.xyz/2020/04/16/C++/&title=《C++》 — The yundingzhishang's blog&pic=www.yundingzhishang.xyz/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.yundingzhishang.xyz/2020/04/16/C++/&title=《C++》 — The yundingzhishang's blog&source=平凡，平静，前进" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=www.yundingzhishang.xyz/2020/04/16/C++/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++》 — The yundingzhishang's blog&url=www.yundingzhishang.xyz/2020/04/16/C++/&via=www.yundingzhishang.xyz" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=www.yundingzhishang.xyz/2020/04/16/C++/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=www.yundingzhishang.xyz/2020/04/16/C++/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '抱歉';
            clearTimeout(titleTime);
        } else {
            document.title = '谢谢你';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
