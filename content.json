{"meta":{"title":"The yundingzhishang's blog","subtitle":"谢谢你这么关照我","description":"平凡，平静，前进","author":"Zcis","url":"www.yundingzhishang.xyz"},"pages":[{"title":"","date":"2020-02-26T14:37:32.060Z","updated":"2020-02-26T14:37:32.049Z","comments":false,"path":"categories/index.html","permalink":"www.yundingzhishang.xyz/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2020-02-26T14:34:42.379Z","updated":"2020-02-26T14:34:42.370Z","comments":false,"path":"tags/index.html","permalink":"www.yundingzhishang.xyz/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"c内存指针","slug":"c内存指针","date":"2020-02-29T12:51:39.000Z","updated":"2020-02-29T12:57:23.801Z","comments":true,"path":"2020/02/29/c内存指针/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/c%E5%86%85%E5%AD%98%E6%8C%87%E9%92%88/","excerpt":"","text":"指针在子母函数的传输 void shhh(int* x) { printf(\"%d\", x); } void main() { int a = 5; int* x =&a; printf(\"%d\\n\", x); shhh(x); } 运行上述程序，所输出结果一致 表面将指针也就是地址传输到子函数中，是修改真正的x而不是子函数新创立的x计算机这时应该会有所警告，而在我的电脑中只要一执行编译这个程序就会有一个特洛伊木马的威胁警告。","raw":null,"content":null,"categories":[{"name":"C内存指针","slug":"C内存指针","permalink":"www.yundingzhishang.xyz/categories/C%E5%86%85%E5%AD%98%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C","slug":"C","permalink":"www.yundingzhishang.xyz/tags/C/"}]},{"title":"堆栈的链表创建","slug":"堆栈的链表操作","date":"2020-02-29T12:48:21.000Z","updated":"2020-02-29T12:58:42.416Z","comments":true,"path":"2020/02/29/堆栈的链表操作/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"#include #include typedef struct SNode* Snode; typedef int ElementType;//易于修改提高精度或者程序可读性 typedef struct SNode { ElementType data; Snode next; }; Snode CreateStack( ){ Snode p; p = (Snode)malloc(sizeof( SNode)); p-&gt;next = NULL; return p;} bool Push(Snode p, ElementType x)//注意用bool{//放入数据 Snode q; q = (Snode)malloc(sizeof(SNode)); q-&gt;data = x; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;} ElementType Pop(Snode p)//判断是否空或者满（不再赘述）{//这个p是一个没有数据的头节点 //取数 //这时的p其实是把地址传送到子函数，这时的p也就是母函数中的p ElementType x= p-&gt;data; Snode q=p-&gt;next;//注意此时的p-&gt;next 发生变化而p未发生变化 p-&gt;next = q-&gt;next; free(p); return x;}","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"堆栈的动态数组创建","slug":"堆栈的动态数组创建","date":"2020-02-29T03:17:35.000Z","updated":"2020-02-29T03:22:30.088Z","comments":true,"path":"2020/02/29/堆栈的动态数组创建/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/%E5%A0%86%E6%A0%88%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"#include #include typedef int Position; typedef struct SNode { Position* arry;//动态数组 Position Maxsize;//最大值 Position tag;//数组的下标 Position data;//该数据 }Snode; Snode* Creat(Position Maxsize)//创建这个堆栈 { Snode* p; p = (Snode*)malloc(sizeof(Snode));//来一个指针指向这个结构体 p->arry = (int*)malloc(Maxsize * sizeof(Position));//创建动态数组的数据 //p->arry[n]=x;可以在此赋值 p->Maxsize = Maxsize; p->tag = -1; return p; } bool Isfull(Snode* p)//往堆栈放时注意是否满了 { if (p->tag == p->Maxsize - 1) return false; else return true; } bool Isempty(Snode* p)//注意空 { if (p->tag == -1) return -1; else return 1; } Snode* Push(Snode* p,Position X) { if (Isfull) { p->arry[++(p->tag)] = X; } else printf(\"full\"); } int Pop(Snode* p) { if (Isempty(p)) return p->arry[(p->tag)--]; else printf(\"isempty\"); }","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"梦","slug":"梦","date":"2020-02-27T15:16:44.000Z","updated":"2020-02-27T15:38:34.516Z","comments":true,"path":"2020/02/27/梦/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/27/%E6%A2%A6/","excerpt":"","text":"The goal in these three yearsThe first of allEacape the influence of othersFind the happiness of technologyBe myself don’t care about others eyesAbandon something may effect me such as gamesDo more things instead speakingMake less friends but they can get along well with meDuring these days,I may also find a life partnerEnjoy the loneless the goalI can work in big companies such as Tencent and alibaba the time2020-2-27 23 :36 nameZcis","raw":null,"content":null,"categories":[{"name":"dream","slug":"dream","permalink":"www.yundingzhishang.xyz/categories/dream/"}],"tags":[]},{"title":"链表的基本操作","slug":"链表的基本操作","date":"2020-02-27T02:26:44.000Z","updated":"2020-02-27T03:20:15.221Z","comments":true,"path":"2020/02/27/链表的基本操作/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/27/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"链表的基本操作有头节点的尾插单链表先建头节点，头节点没有存放数据，尾插是从左往右需要3个结构指针 #include #include typedef struct Node { int x; struct Node* next; }node; int main() { node* head; node* p; node*q; head = (Node *)malloc(sizeof(node)); head->next = NULL; p = head; int t; for (t = 1; t x); p->next = q; p = q; } p->next = NULL; return 0; } ![尾插法]（https://raw.githubusercontent.com/LINGyue-dot/a-mass-of-photos/master/blog/%E5%B0%BE%E6%8F%92%E6%B3%95.png） 带头指针的头插法从右往左开始输入插入，一样头指针没有存放数据,若要按正序的，一样也需要3个结构指针 #include//head cut #include typedef struct Node { int x; struct node* next; }node; int main() { node* head, * p; head = (node*)malloc(sizeof(node)); head->next = NULL; int t = 0; for (t = 1; t x); p->next = head->next; head->next = p; } while (p != NULL) { printf(\"%d\", p->x); p = p->next; } return 0; } 头插法","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"recursive algorithm","slug":"recursive-algorithm","date":"2020-02-26T09:05:51.000Z","updated":"2020-02-27T03:10:46.712Z","comments":true,"path":"2020/02/26/recursive-algorithm/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/recursive-algorithm/","excerpt":"","text":"递归","raw":null,"content":null,"categories":[{"name":"代码经验","slug":"代码经验","permalink":"www.yundingzhishang.xyz/categories/%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"浙大数据结构笔记---最大连续子数列","slug":"浙大数据结构笔记-最大连续子数列","date":"2020-02-26T07:51:58.000Z","updated":"2020-02-26T15:00:30.778Z","comments":true,"path":"2020/02/26/浙大数据结构笔记-最大连续子数列/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97/","excerpt":"","text":"最大连续子数列在线处理法在线处理法 #include \"stdio.h\" int main() { int arry[11]; int x, Maxsum = 0, Thissum = 0; for (x = 0; x Maxsum)Maxsum = Thissum; else if (Thissum 从左往右开始扫描，若现在的Thissum为负数就丢弃，比较大就替代。 分而治之的递归算法 #include int Maxs(int x, int y, int z) { return x > y ? x > z ? x : z : y > z ? y : z; } int Maxsum(int left, int right, int arry[]) { if (left == right) if (arry[right] = left; i--) { sum += arry[i]; if (sum > maxsumleft)maxsumleft = sum; }//先计算从中间线开始左边的最大值 sum = 0; for (i = center + 1; i maxsumright)maxsumright = sum; }//再计算右边最大值注意是连续的 return Maxs(leftsum, rightsum, maxsumleft + maxsumright); } int main() { int arry[101]; int i, j; scanf(\"%d\", &j); for (i = 0; i 大概流程","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]}]}