{"meta":{"title":"The yundingzhishang's blog","subtitle":"谢谢你这么关照我","description":"平凡，平静，前进","author":"Zcis","url":"www.yundingzhishang.xyz"},"pages":[{"title":"","date":"2020-02-26T14:34:42.379Z","updated":"2020-02-26T14:34:42.370Z","comments":false,"path":"tags/index.html","permalink":"www.yundingzhishang.xyz/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2020-02-26T14:37:32.060Z","updated":"2020-02-26T14:37:32.049Z","comments":false,"path":"categories/index.html","permalink":"www.yundingzhishang.xyz/categories/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"字符串处理","slug":"字符串处理","date":"2020-03-05T08:07:23.000Z","updated":"2020-03-05T08:35:11.021Z","comments":true,"path":"2020/03/05/字符串处理/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"大位数乘法乘法 Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.Input Specification:Each input contains one test case. Each case contains one positive integer with no more than 20 digits.Output Specification:For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.Sample Input: 1234567899Sample Output: Yes\\n2469135798 #include #include #include char doubleit(char str[], int x);bool ist(char str[], int length);char ch = 32;//创建一个可能多出一位的最大的位数的数 bool ist(char str[],int last)//是否两者的数都互有涵盖{ int arry[10] = { 0 }, arrys[10] = { 0 };//记得桶排 for (int x = 0; x &lt;= last; x++) arry[str[x] - 48] = 1; ch=doubleit(str, last); for (int x = 0; x &lt;= last; x++) arrys[str[x] - 48] = 1; if(ch!=32) arrys[ch - 48] = 1; int flag=1; for (int x = 0; x &lt;= 9; x++)//比较同样记得可以用strcamp（字符串比较时） if (arry[x] != arrys[x])flag = 0; if (flag) return true;//0是false，非0都是true else return false;} char doubleit(char str[], int last){ int x = 0,temp,lastone=0;//lastone用来记录进位,temp作为一个中间值 for ( x = last; x&gt;=0 ; x–)//开始乘法 { temp = (str[x] - 48) * 2 ;//取模 str[x] = temp%10 + 48+lastone; lastone = temp / 10; if (x == 0 &amp;&amp; lastone != 0) ch = lastone + 48; } return ch;} int main(){ char str[22]; int lastnumber; scanf(“%s”, str);//scanf会自动补’\\0’ lastnumber = strlen(str)-1;//strlen不包括’\\0’ if (ist(str, lastnumber))printf(“Yes\\n”); else printf(“No\\n”); if (ch != 32) printf(“%c%s”, ch, str); else printf(“%s”, str); return 0;} 总结大数据做运算用字符串来存放，注意的点1.数据是“倒序存放”，这时就一定注意可能多出来一位，需要再构建一位2.进位问题，有可能是1也有可能是2，所以用取模的方法就较为简单3.若有对比问题，flag或者memset都要想到4.同样可以建多数组，将计算结果直接存放在新数列","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"www.yundingzhishang.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"记一道数组循环移动的反思","slug":"记一道数组循环移动的反思","date":"2020-03-04T08:20:03.000Z","updated":"2020-03-04T09:00:34.496Z","comments":true,"path":"2020/03/04/记一道数组循环移动的反思/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/04/%E8%AE%B0%E4%B8%80%E9%81%93%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%8F%8D%E6%80%9D/","excerpt":"","text":"一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。输入样例:6 21 2 3 4 5 6输出样例:5 6 1 2 3 4 注意此题N与M大小关系都有可能存在 常规思维通过改变输出的方式，“伪” 改成数组右移 #include int main() { int N, M; scanf(\"%d %d\", &N, &M); int arry[101]; for (int x=1; x = N)M -= N;//M是有可能大于N的 for (int x = N - M + 1; x 动态数组 #include #include int main(){ int N, M, * arry; scanf(“%d %d”, &amp;N, &amp;M); arry = (int*)malloc((N + 1) * sizeof(int)); M = M % N; for (int x = M + 1; x &lt;= N; x++) scanf(“%d”, &amp;arry[x]); for (int x = 1; x &lt;= M; x++) scanf(“%d”, &amp;arry[x]); for (int x = 1; x &lt;= N; x++) { if (x != N)printf(“%d “, arry[x]); else printf(“%d”, arry[x]); } return 0;} 这个做法主要突出动态数组来创建数组和非常规的输入完成所需要的输出和取模操作来确定实际的移动","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"反思","slug":"反思","permalink":"www.yundingzhishang.xyz/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"素数有关猜想猜想","slug":"素数有关猜想猜想","date":"2020-03-03T11:34:11.000Z","updated":"2020-03-03T11:41:07.792Z","comments":true,"path":"2020/03/03/素数有关猜想猜想/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/03/%E7%B4%A0%E6%95%B0%E6%9C%89%E5%85%B3%E7%8C%9C%E6%83%B3%E7%8C%9C%E6%83%B3/","excerpt":"","text":"让我们定义dn为：dn=n+1−pn，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N(&lt;105次方)，请计算不超过N的满足猜想的素数对的个数。输入格式:输入在一行给出正整数N。输出格式:在一行中输出不超过N的满足猜想的素数对的个数。输入样例:20输出样例:4 #include #include #include bool iss(int x){ int n = 2,flag=1; for (; n &lt;= sqrt(x); n++) if (x % n == 0)flag = 0; if (flag == 1)return 1; else return 0;} int main(){ int n; scanf(“%d”, &amp;n); int x = 1,sum=0; int x1 = 2,x2; for (x = 2; x &lt;= n; x++) { x2 = x1; if (iss(x))x1 = x; if (x1 - x2 == 2)sum++; } printf(“%d”, sum); return 0;}.h文件，bool属于c++的范畴里判断素数的方法熟记 ,同时bool需要有stdbool.h文件，bool属于c++的范畴里","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"素数","slug":"素数","permalink":"www.yundingzhishang.xyz/tags/%E7%B4%A0%E6%95%B0/"}]},{"title":"打印图形题","slug":"记打印图像水题反思","date":"2020-03-01T05:03:16.000Z","updated":"2020-03-03T09:24:57.372Z","comments":true,"path":"2020/03/01/记打印图像水题反思/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/01/%E8%AE%B0%E6%89%93%E5%8D%B0%E5%9B%BE%E5%83%8F%E6%B0%B4%E9%A2%98%E5%8F%8D%E6%80%9D/","excerpt":"","text":"沙漏类型题 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 ***** *** * *** ***** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。输入样例:19 *输出样例: ***** *** * *** ***** 2 #include #include int main() { int N; char ch; scanf(\"%d %c\", &N, &ch); int k = sqrt((N + 1) / 2); int Number = k, SPACE=0; int space=0, charnumber,x; for (; k >= 1; k--,space++) { for (x = 0; x 注意结尾记得把多余的k--与space++还回来 k += 2; space-=2; for (; k 该题主要需要寻找行与需打印空格和符号的数量之间的关系图形题主要就是找行与特殊符号之间的关系而这道题用奇数来打印特殊符号即得出以下特殊规律（记忆）从1开始的奇数项的和等于该奇数数目的平方即1+3+……+(2n+1)=n*n 杨辉三角 【输入形式】从键盘输入整数n（n&gt;=0且n&lt;=12）【输出形式】在屏幕上输出n+1行杨辉三角形。【输入样例】3【输出样例】------***1----***1***1--***1***2***1***1***3***3***1其中－和*都是空格位即每个数字占四位！ #include int main() { int n; scanf(\"%d\", &n); int arry[14][14] = { 0 }; int x, y,space; for (x = 1; x 2 * (n - x); space++) printf(\" \"); for (y = 1; y 同样杨辉三角主要是考虑前面空格数和行数的关系这题就可以用“倒”数的方法来进行行的计算","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"打印图像","slug":"打印图像","permalink":"www.yundingzhishang.xyz/tags/%E6%89%93%E5%8D%B0%E5%9B%BE%E5%83%8F/"}]},{"title":"c内存指针","slug":"c内存指针","date":"2020-02-29T12:51:39.000Z","updated":"2020-02-29T12:57:23.801Z","comments":true,"path":"2020/02/29/c内存指针/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/c%E5%86%85%E5%AD%98%E6%8C%87%E9%92%88/","excerpt":"","text":"指针在子母函数的传输 void shhh(int* x) { printf(\"%d\", x); } void main() { int a = 5; int* x =&a; printf(\"%d\\n\", x); shhh(x); } 运行上述程序，所输出结果一致 表面将指针也就是地址传输到子函数中，是修改真正的x而不是子函数新创立的x计算机这时应该会有所警告，而在我的电脑中只要一执行编译这个程序就会有一个特洛伊木马的威胁警告。","raw":null,"content":null,"categories":[{"name":"C内存指针","slug":"C内存指针","permalink":"www.yundingzhishang.xyz/categories/C%E5%86%85%E5%AD%98%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C","slug":"C","permalink":"www.yundingzhishang.xyz/tags/C/"}]},{"title":"堆栈的链表创建","slug":"堆栈的链表操作","date":"2020-02-29T12:48:21.000Z","updated":"2020-02-29T12:58:42.416Z","comments":true,"path":"2020/02/29/堆栈的链表操作/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"#include #include typedef struct SNode* Snode; typedef int ElementType;//易于修改提高精度或者程序可读性 typedef struct SNode { ElementType data; Snode next; }; Snode CreateStack( ){ Snode p; p = (Snode)malloc(sizeof( SNode)); p-&gt;next = NULL; return p;} bool Push(Snode p, ElementType x)//注意用bool{//放入数据 Snode q; q = (Snode)malloc(sizeof(SNode)); q-&gt;data = x; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;} ElementType Pop(Snode p)//判断是否空或者满（不再赘述）{//这个p是一个没有数据的头节点 //取数 //这时的p其实是把地址传送到子函数，这时的p也就是母函数中的p ElementType x= p-&gt;data; Snode q=p-&gt;next;//注意此时的p-&gt;next 发生变化而p未发生变化 p-&gt;next = q-&gt;next; free(p); return x;}","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"堆栈的动态数组创建","slug":"堆栈的动态数组创建","date":"2020-02-29T03:17:35.000Z","updated":"2020-02-29T03:22:30.088Z","comments":true,"path":"2020/02/29/堆栈的动态数组创建/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/%E5%A0%86%E6%A0%88%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"#include #include typedef int Position; typedef struct SNode { Position* arry;//动态数组 Position Maxsize;//最大值 Position tag;//数组的下标 Position data;//该数据 }Snode; Snode* Creat(Position Maxsize)//创建这个堆栈 { Snode* p; p = (Snode*)malloc(sizeof(Snode));//来一个指针指向这个结构体 p->arry = (int*)malloc(Maxsize * sizeof(Position));//创建动态数组的数据 //p->arry[n]=x;可以在此赋值 p->Maxsize = Maxsize; p->tag = -1; return p; } bool Isfull(Snode* p)//往堆栈放时注意是否满了 { if (p->tag == p->Maxsize - 1) return false; else return true; } bool Isempty(Snode* p)//注意空 { if (p->tag == -1) return -1; else return 1; } Snode* Push(Snode* p,Position X) { if (Isfull) { p->arry[++(p->tag)] = X; } else printf(\"full\"); } int Pop(Snode* p) { if (Isempty(p)) return p->arry[(p->tag)--]; else printf(\"isempty\"); }","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"梦","slug":"梦","date":"2020-02-27T15:16:44.000Z","updated":"2020-02-27T15:38:34.516Z","comments":true,"path":"2020/02/27/梦/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/27/%E6%A2%A6/","excerpt":"","text":"The goal in these three yearsThe first of allEacape the influence of othersFind the happiness of technologyBe myself don’t care about others eyesAbandon something may effect me such as gamesDo more things instead speakingMake less friends but they can get along well with meDuring these days,I may also find a life partnerEnjoy the loneless the goalI can work in big companies such as Tencent and alibaba the time2020-2-27 23 :36 nameZcis","raw":null,"content":null,"categories":[{"name":"dream","slug":"dream","permalink":"www.yundingzhishang.xyz/categories/dream/"}],"tags":[]},{"title":"链表的基本操作","slug":"链表的基本操作","date":"2020-02-27T02:26:44.000Z","updated":"2020-02-27T03:20:15.221Z","comments":true,"path":"2020/02/27/链表的基本操作/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/27/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"链表的基本操作有头节点的尾插单链表先建头节点，头节点没有存放数据，尾插是从左往右需要3个结构指针 #include #include typedef struct Node { int x; struct Node* next; }node; int main() { node* head; node* p; node*q; head = (Node *)malloc(sizeof(node)); head->next = NULL; p = head; int t; for (t = 1; t x); p->next = q; p = q; } p->next = NULL; return 0; } ![尾插法]（https://raw.githubusercontent.com/LINGyue-dot/a-mass-of-photos/master/blog/%E5%B0%BE%E6%8F%92%E6%B3%95.png） 带头指针的头插法从右往左开始输入插入，一样头指针没有存放数据,若要按正序的，一样也需要3个结构指针 #include//head cut #include typedef struct Node { int x; struct node* next; }node; int main() { node* head, * p; head = (node*)malloc(sizeof(node)); head->next = NULL; int t = 0; for (t = 1; t x); p->next = head->next; head->next = p; } while (p != NULL) { printf(\"%d\", p->x); p = p->next; } return 0; } 头插法","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"recursive algorithm","slug":"recursive-algorithm","date":"2020-02-26T09:05:51.000Z","updated":"2020-02-27T03:10:46.712Z","comments":true,"path":"2020/02/26/recursive-algorithm/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/recursive-algorithm/","excerpt":"","text":"递归","raw":null,"content":null,"categories":[{"name":"代码经验","slug":"代码经验","permalink":"www.yundingzhishang.xyz/categories/%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"浙大数据结构笔记---最大连续子数列","slug":"浙大数据结构笔记-最大连续子数列","date":"2020-02-26T07:51:58.000Z","updated":"2020-02-26T15:00:30.778Z","comments":true,"path":"2020/02/26/浙大数据结构笔记-最大连续子数列/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97/","excerpt":"","text":"最大连续子数列在线处理法在线处理法 #include \"stdio.h\" int main() { int arry[11]; int x, Maxsum = 0, Thissum = 0; for (x = 0; x Maxsum)Maxsum = Thissum; else if (Thissum 从左往右开始扫描，若现在的Thissum为负数就丢弃，比较大就替代。 分而治之的递归算法 #include int Maxs(int x, int y, int z) { return x > y ? x > z ? x : z : y > z ? y : z; } int Maxsum(int left, int right, int arry[]) { if (left == right) if (arry[right] = left; i--) { sum += arry[i]; if (sum > maxsumleft)maxsumleft = sum; }//先计算从中间线开始左边的最大值 sum = 0; for (i = center + 1; i maxsumright)maxsumright = sum; }//再计算右边最大值注意是连续的 return Maxs(leftsum, rightsum, maxsumleft + maxsumright); } int main() { int arry[101]; int i, j; scanf(\"%d\", &j); for (i = 0; i 大概流程","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]}]}