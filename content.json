{"meta":{"title":"The yundingzhishang's blog","subtitle":"谢谢你这么关照我","description":"平凡，平静，前进","author":"Zcis","url":"www.yundingzhishang.xyz"},"pages":[{"title":"","date":"2020-02-26T14:34:42.379Z","updated":"2020-02-26T14:34:42.370Z","comments":false,"path":"tags/index.html","permalink":"www.yundingzhishang.xyz/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2020-02-26T14:37:32.060Z","updated":"2020-02-26T14:37:32.049Z","comments":false,"path":"categories/index.html","permalink":"www.yundingzhishang.xyz/categories/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"浙大数据结构笔记---最大连续子数列","slug":"浙大数据结构笔记-最大连续子数列","date":"2020-02-26T07:51:58.000Z","updated":"2020-02-26T15:00:30.778Z","comments":true,"path":"2020/02/26/浙大数据结构笔记-最大连续子数列/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97/","excerpt":"","text":"最大连续子数列在线处理法在线处理法 #include \"stdio.h\" int main() { int arry[11]; int x, Maxsum = 0, Thissum = 0; for (x = 0; x Maxsum)Maxsum = Thissum; else if (Thissum 从左往右开始扫描，若现在的Thissum为负数就丢弃，比较大就替代。 分而治之的递归算法 #include int Maxs(int x, int y, int z) { return x > y ? x > z ? x : z : y > z ? y : z; } int Maxsum(int left, int right, int arry[]) { if (left == right) if (arry[right] = left; i--) { sum += arry[i]; if (sum > maxsumleft)maxsumleft = sum; }//先计算从中间线开始左边的最大值 sum = 0; for (i = center + 1; i maxsumright)maxsumright = sum; }//再计算右边最大值注意是连续的 return Maxs(leftsum, rightsum, maxsumleft + maxsumright); } int main() { int arry[101]; int i, j; scanf(\"%d\", &j); for (i = 0; i 大概流程","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]}]}