{"meta":{"title":"The yundingzhishang's blog","subtitle":"谢谢你这么关照我","description":"平凡，平静，前进","author":"Zcis","url":"www.yundingzhishang.xyz"},"pages":[{"title":"","date":"2020-02-26T14:37:32.060Z","updated":"2020-02-26T14:37:32.049Z","comments":false,"path":"categories/index.html","permalink":"www.yundingzhishang.xyz/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2020-02-26T14:34:42.379Z","updated":"2020-02-26T14:34:42.370Z","comments":false,"path":"tags/index.html","permalink":"www.yundingzhishang.xyz/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"链表的基本操作","slug":"链表的基本操作","date":"2020-02-27T02:26:44.000Z","updated":"2020-02-27T03:10:43.749Z","comments":true,"path":"2020/02/27/链表的基本操作/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/27/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"链表的基本操作有头节点的尾插单链表先建头节点，头节点没有存放数据，尾插是从左往右需要3个结构指针 #include #include typedef struct Node { int x; struct Node* next; }node; int main() { node* head; node* p; node*q; head = (Node *)malloc(sizeof(node)); head->next = NULL; p = head; int t; for (t = 1; t x); p->next = q; p = q; } p->next = NULL; return 0; } ![尾插法]（https://raw.githubusercontent.com/LINGyue-dot/a-mass-of-photos/master/blog/%E5%B0%BE%E6%8F%92%E6%B3%95.png） 带头指针的头插法从右往左开始输入插入，一样头指针没有存放数据,若要按正序的，一样也需要3个结构指针 #include//head cut #include typedef struct Node { int x; struct node* next; }node; int main() { node* head, * p; head = (node*)malloc(sizeof(node)); head->next = NULL; int t = 0; for (t = 1; t x); p->next = head->next; head->next = p; } while (p != NULL) { printf(\"%d\", p->x); p = p->next; } return 0; } 头插法","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"recursive algorithm","slug":"recursive-algorithm","date":"2020-02-26T09:05:51.000Z","updated":"2020-02-27T03:10:46.712Z","comments":true,"path":"2020/02/26/recursive-algorithm/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/recursive-algorithm/","excerpt":"","text":"递归","raw":null,"content":null,"categories":[{"name":"代码经验","slug":"代码经验","permalink":"www.yundingzhishang.xyz/categories/%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"浙大数据结构笔记---最大连续子数列","slug":"浙大数据结构笔记-最大连续子数列","date":"2020-02-26T07:51:58.000Z","updated":"2020-02-26T15:00:30.778Z","comments":true,"path":"2020/02/26/浙大数据结构笔记-最大连续子数列/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97/","excerpt":"","text":"最大连续子数列在线处理法在线处理法 #include \"stdio.h\" int main() { int arry[11]; int x, Maxsum = 0, Thissum = 0; for (x = 0; x Maxsum)Maxsum = Thissum; else if (Thissum 从左往右开始扫描，若现在的Thissum为负数就丢弃，比较大就替代。 分而治之的递归算法 #include int Maxs(int x, int y, int z) { return x > y ? x > z ? x : z : y > z ? y : z; } int Maxsum(int left, int right, int arry[]) { if (left == right) if (arry[right] = left; i--) { sum += arry[i]; if (sum > maxsumleft)maxsumleft = sum; }//先计算从中间线开始左边的最大值 sum = 0; for (i = center + 1; i maxsumright)maxsumright = sum; }//再计算右边最大值注意是连续的 return Maxs(leftsum, rightsum, maxsumleft + maxsumright); } int main() { int arry[101]; int i, j; scanf(\"%d\", &j); for (i = 0; i 大概流程","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]}]}