{"meta":{"title":"The yundingzhishang's blog","subtitle":"谢谢你这么关照我","description":"平凡，平静，前进","author":"Zcis","url":"www.yundingzhishang.xyz"},"pages":[{"title":"","date":"2020-02-26T14:37:32.060Z","updated":"2020-02-26T14:37:32.049Z","comments":false,"path":"categories/index.html","permalink":"www.yundingzhishang.xyz/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2020-02-26T14:34:42.379Z","updated":"2020-02-26T14:34:42.370Z","comments":false,"path":"tags/index.html","permalink":"www.yundingzhishang.xyz/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"博客建立2中易上手姿势","slug":"wordpress-阿里云建博客","date":"2020-05-08T02:04:27.000Z","updated":"2020-05-08T02:20:33.861Z","comments":true,"path":"2020/05/08/wordpress-阿里云建博客/","link":"","permalink":"www.yundingzhishang.xyz/2020/05/08/wordpress-%E9%98%BF%E9%87%8C%E4%BA%91%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Hexo + github 的静态博客基础部署环境： node git安装nodejspowershell 管理员权限检查node -v and npm -v下载淘宝源 cnpm:npm install cnpm -g –registry=https://registry.npm.taobao.org这时全局安装 在User/admin/appdata/Roaming/npm检查 cnpm如果出错 脚本禁止说明管理员权限不够，powershell 输入Start-Process powershell -Verb runAs再输入：set-ExecutionPolicy RemoteSigned A检查 cnpm安装hexo： cnpm install -g hexo -cli先到cnpm上下载安装git重启powershell 管理员权限cd bolg\\ 进入blog文件夹（要空）hexo init ：开始克隆hexo s（serve） :开始查看这个本地hexohexo n “我的第一篇博客”：创建一个新博客名字叫我的第一篇博客ls 查看后应该有 我的第一篇博客.md进入修改 linux和mac 有vim win 就用notepad 我的第一篇博客.md就是记事本进入修改这个博客，或者vc的md插件hexo clean ：清除这个项目缓存hexo g (generate) : 生成一个静态的html修改_config.yml （注意用管理员命令行方式以notepad打开创建仓库的名称注意是 昵称.github.io(LINGyue-dot.github.io)将最下面的type及一下修改成type: gitrepo:（GitHub仓库里的https或者SSH的地址）branch : masterhexo d（deploy）：上传这个项目打开 .git 里的config（全部文件类型无后缀）notepad打开在上方添加[user]email = your emailname = your name （填写github的）再 hexo d 部署到仓库中 输入github账号密码即可 ( 用git bash 的话可以直接跳出来登入框）如果出现 ERROR Deployer not found: git得 npm install hexo-deployer-git –save克隆主题git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia后面的.git theme/yilia 是克隆到.git 文件中的theme 里并且命名为yilia而https://github.com/litten/hexo-theme-yilia是别人主题仓库地址修改主题hexo cleanhexo ghexo shexo d即部署到远端去了 Wordpress+aliyun1.域名解析 + 备案 + 购买服务器2.系统自定 推荐ubuntu centos3.连接 到服务器用阿里云网站的ESC管理控制台里的远程连接Workbench和VNC或者xshell 和xftp 安装宝塔面板4.宝塔面板 https://www.bt.cn/bbs/thread-19376-1-1.html5.用bt提供地username 和password 登入Bt-Panel6.进去一键安装LAMP 将php版本修改一下，改成7.3以上（wordpress大多地%x地商店得要7.3以上才可支持）7.bt面板选择网站添加站点，选择mysql php选7.38.文件上选在站点的根目录下上传wordpress ，并且解压复制到站点根目录,不是子目录，例如 域名是yundingzhishang.xyz 根目录就是yundingzhishang.xyz","raw":null,"content":null,"categories":[{"name":"操作","slug":"操作","permalink":"www.yundingzhishang.xyz/categories/%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"建站","slug":"建站","permalink":"www.yundingzhishang.xyz/tags/%E5%BB%BA%E7%AB%99/"}]},{"title":"HTMLCSS细节问题","slug":"HTMLCSS细节问题","date":"2020-05-05T13:30:23.000Z","updated":"2020-05-05T13:37:57.524Z","comments":true,"path":"2020/05/05/HTMLCSS细节问题/","link":"","permalink":"www.yundingzhishang.xyz/2020/05/05/HTMLCSS%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/","excerpt":"","text":"标签问题img的下方空白问题原因： 基线对齐 https://www.cnblogs.com/axu1997/p/11758521.html 解决： 用vertical-align:middle 因为行内块元素默认是基线对齐，使其变成底线对齐 li之间的空隙问题 原因：li标签之间存在空格导致 首先 ul里面的padding :0px ,list-style:none ; https://blog.csdn.net/mayerlucky/article/details/51811917 解决： 1.浮动解决 2. ul的font-size =0 再设置 li font-size 3.用注释将li标签之间的空格去掉","raw":null,"content":null,"categories":[],"tags":[{"name":"HTMLCSS","slug":"HTMLCSS","permalink":"www.yundingzhishang.xyz/tags/HTMLCSS/"}]},{"title":"git","slug":"git","date":"2020-05-05T13:24:05.000Z","updated":"2020-06-08T09:52:18.133Z","comments":true,"path":"2020/05/05/git/","link":"","permalink":"www.yundingzhishang.xyz/2020/05/05/git/","excerpt":"","text":"首次创建 可以用创建空仓库clone下来 或者先创文件再链接仓库 cd 到文件 目录下 将文件复制到这。通过git init命令把这个项目变成一个Git可以管理的仓库 git status 查看是否有新文件 git add ./ git add.文件名 上传所有 或者add 文件 到本地的仓库 git commit -m “第一次提交” ，提交备注信息 git push -u origin master 到远程仓库即可 更新 git pull 将GitHub上的代码下下来并合并代码，防止提交新代码出错 git add 将代码添加到仓库 git commit 将代码提交到仓库 git push 将代码提交到GitHub","raw":null,"content":null,"categories":[{"name":"工具使用","slug":"工具使用","permalink":"www.yundingzhishang.xyz/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"git","slug":"git","permalink":"www.yundingzhishang.xyz/tags/git/"}]},{"title":"C++代码区域","slug":"C-代码区域","date":"2020-04-16T09:53:07.000Z","updated":"2020-06-08T09:58:45.546Z","comments":true,"path":"2020/04/16/C-代码区域/","link":"","permalink":"www.yundingzhishang.xyz/2020/04/16/C-%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"代码区域 ##### 1 #include #include using namespace std; class Point { public: Point() :x(0), y(0) { cout = 0 && index using namespace std; class A { public: A(int x,int y):real(x),image(y){} void show()const { cout using namespace std; class A { public: A(int x,int y):real(x),image(y){} void show()const { cout using namespace std; class A { public: void show() { cout show(); } int main() { A a; B b; C c; fun(&a); fun(&b); fun(&c);//这时都只访问A，并没有我们所计划的通过A，B，C访问 return 0; } ##### 5 #include using namespace std; class A { public: virtual void show() = 0;虚函数不是内联的 };class B:public A { public: void show() { cout show(); } int main() { B b; C c; fun(&b); fun(&c);//这时都只访问A return 0; } ##### 6 #include #include using namespace std; template class Array { private: T* p;//指向首地址的指针 int size;//数组大小 public: Array(int size = 50);//构造函数 Array(const Array& a);//复制构造函数只读 ~Array();//析构 Array & operator = (const Array & rhs);//重载赋值运算符 //注意函数写法 Array& operator[] (int n);//检查【】是否越界 operator T*();//*重载//**为什么这里前面不用Array** }; template Array::Array(int sz)//构造函数 { if (sz > 0) size = sz; p = new T[size];//分配空间 } template Array::~Array()//析构函数 { delete[]p; } template Array::Array(const Array& a) { size = a.size; p = new T[size];//注意这里必须是深复制 for (int x = 0; x Array& Array ::operator =(const Array& rhs) { //注意函数写法 //赋值，意思是个对象已经存在了一段时间后再进行 //复制构造是这个对象刚刚创建时候就复制 if (rhs != this)//表明复制的和所操作的不是同一个 { if (size != rhs.size) { delete[] p; size = rhs.size; p = new T[size]; } for (int i = 0; i Array& Array::operator[](int n)//设置为引用或者const引用 { assert(n > 0 && n Array::operator T*()//对对象直接转换为T* { return p; } void read(int* p, int n) { for (int i = 0; i > p[i]; } int main() { Array a(10); //read(a, 10);这里需要*重载,直接将对象转换为指针类型 read(a, 10); return 0; } 1--5几种排列方式 小问题区域1.数组int a【5】；a=a+2；错误，这个首地址无法改变 只能a+2访问","raw":null,"content":null,"categories":[{"name":"语言基础知识","slug":"语言基础知识","permalink":"www.yundingzhishang.xyz/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"www.yundingzhishang.xyz/tags/C/"}]},{"title":"C++","slug":"C++","date":"2020-04-16T09:52:54.000Z","updated":"2020-06-08T09:58:11.829Z","comments":true,"path":"2020/04/16/C++/","link":"","permalink":"www.yundingzhishang.xyz/2020/04/16/C++/","excerpt":"","text":"C++基础语言标识符：即变量名，函数名，宏名等 存储类型：auto（默认不写） extern static A类内函数：B类名 &amp; 函数名 {} 意思是返回值是B类的引用 &amp;&amp; 右值引用 ：即将消亡的值 &amp; 左值引用 被继承已有类：基类（父类） 派生出的新类称为派生类（子类） 对象成员：A类对象作为B类成员时，A类对象称为对象成员 最远派生类：建立对象所指定的类 &amp;函数名：返回值是地址值，可以节约空间，而不必再创建一个临时对象赋值 群体：由多个数据元素组成的集合体 线性群体：按位置排列有序的 非线性群体：不按位置顺序来标识元素 U：前置单目运算符 引用和指针一致，传地址到子函数中，值可以直接被修改 带默认行参的函数clock（int x，int y=2） 必须要从左往右赋值，因为参数入栈顺序是从右往左 初始化列表和缺省参数值初始化列表：在函数之后冒号 ​ clock（int x,int y): hour(x),miniute(y){} 缺省参数值：默认值 构造函数没有返回值 析构函数没有返回值，如果未定义，那么就只有系统默认的空函数体的析构函数，是在对象生存期快要结束的时刻被自动调用，对象的内存空间被释放 块作用域、例如子函数中的形参，到大括号结束 类作用域引用这个类的对象 例如在主函数中声明了myclock，那么这个主函数也是myclock的类作用域，或者某一子函数中声明引用 重载函数函数名相同，但是形参的数量和数据类型是有一不同，且不以返回值类型进行区分。 友元class A { public： friend class B} B就可以直接访问A的private 数据 单向，非继承 在类中对数据直接初始化c++11中是可以的，但是初始化的值会被构造函数初始化列表的值所覆盖 常对象const clock myclock 前面或者后面有const 只能调用对象里面的常成员函数或者静态函数（本质上调用静态函数时候只是借用了常对象实质上是调用了类） 常成员函数void showtime（） const //const只能放后面如果放前面意味着返回值是常量 常成员函数是只能读取同类数据成员的值而不能修改他 const可以用于重载，如果非const对象调用该函数时。调用没有const的重载函数 静态成员函数只属于类，其余非静态成员函数（包括常成员函数）是属于对象的。 静态数据static int count； const clock ::count=0； 静态数据成员只能再类定义之外加以赋值 const相关普通数据：如果是int 或者 const int 的话就可以互相赋值但是const int 必须初始化 指针：指针类型必须要和所指的对象类型相同 例外一：const int* 指向常量的指针可以指向非常量的指针int （指针类型的常量：int* const ）注意指向字符串的指针是不能通过指针来修改字符串的等价于 char *p= … const char *p=….. 引用：const int&amp;可以引用一个非const的对象：const int &amp; = int ，同样const int x=double （只是在c++中本质上创造一个const int temp= double ，再让x=temp，所以x实质上是引用一个临时量temp，所以x只允许是const类型，才可以跨类型“引用”） 所有的指向常量的指针或者是引用其实都是无法通过引用或者这个指针来修改他原本的值。const int &amp;或者const int* 静态的全局变量不能被其他文件共享，但是全局变量可以 静态常数据static const int b 同静态数据只能再类定义之外加以赋值，但是如果是具有int和enum类型就可以直接写，若在类中已经定义了初值，那么不能在类定义外再赋初值 常数据成员const int a或者int const a 不能在类中直接赋值，只能通过构造函数并且必须在所有的构造函数中进行初始化 常引用类里面{int sum(const clock &amp;clock1,const clock &amp;clock2)} const clock myclock(1,2),yourclock(3,4); int sum(myclock,yourclock) 可以让myclock和yourclok避免被修改。 多文件结构和编译预处理c++一般组织结构三个文件： .h)类的定义 不需要空间的声明以及内联函数的的定义，外部变量和外部函数的引用性声明，不要给变量定义性声明（赋值） .cpp)类的实现，类里面的函数的具体实现 .cpp)主函数只能写一个 两个cpp文件都需要包含include文件，在被编译成obj文件后3个文件再连接成exe文件 文件之间共享数据问题extern +全局变量：文件之间共享数据 static +全局变量：取消文件之间的共享 外部变量（本文件的全局变量）用于声明外部变量 extern int x 一般只用于声明变量，如果未赋值那么就是引用性声明，赋值就是定义性声明，但是变量只能有一处的定义性声明。如果在基本无法在函数内部对一个变量定义声明。引用式声明的作用域与原变量一致。 外部函数在所有类外的可以加extern externint和 extern int 的区别 错误：例如 h文件中 int x 这时候是不能赋值的，然而 这时如果在cpp中int x或者int x=的话就会重定义报错 解决：h文件中extern int 不可赋值 ，再到cpp文件中进行赋值即可，并且 这个只占一个内存空间 注意编译过程是先各个文件编译再进行链接的这个extern只在链接时候起作用，在编译文件时候就只是告诉编译器这个是是一个来自其他文件的变量，虽然找不到他但是不会报错 匿名的命名空间不希望被其他编译单元（一个cpp源文件）引用的函数和变量都在这 namespace { int n； 宏定义#ifndef&lt; if not define&gt;//测试是否被宏定义过，定义过返回假 #define 1 //正文 #else 2 //如果定义过则编译2 #endif //终止 数组二维数组在内存中是按行存放的 对象数组clock a[n]，这里每一个a 用于存放类中的所有私有数据，默认是调用构造函数进行对私有数据进行初始化，如果不想初始化赋值那么就需要定义一个默认的构造函数（不可以少） 例如 clock public：clock（int x=1 ,int y=2):x(x),y(y){} pirvate：int x，int y. int main(){ clock a[2]} ，那么a[0]={x= 1，y=2} a[1] ={x= 1，y=2} 指针（声明，赋值，引用）int *p=NULL == int *p=0； 指向常量的指针const int *p=&amp;a；p可以改，但是不可以通过 *p来修改a 指针类型的常量int const *p= &amp;a ，p不可 引用（并不是一个对象）int &amp;refVal=ival refVal是ival的另外的名字（引用必须被初始化）相当起了另外一个名字没有地址，并且类型需要一致 ival也要int，并且只能绑定到对象上，不能int &amp;refVal=1；，注意指针无法指向引用 不合法指针指向错误内存地址或野指针，即必须保证操作指针时，指针所指的对象是有效的，指针不为空。也需要类型一致 指针是否有效p==NULL，空指针就无效 其他指针操作其他指针操作可以用作bool类型进行判断详情见c++primer第五版 p50，例如int*p=0；if（ p） 如果==，比较的是地址值，而不是变量值。 指针有关的boolint a=5;int *p= a; if(p):p判断是否为空 if（*p）：判断a是否为0； 函数指针存储类型 类型 （*函数指针名）（形参的数据类型） void （* function）（float） 存储类型：auto（默认不写） extern static 指向函数 void showtime（float a） funciton=（&amp;）showtime；//指向函数，&amp;可写可不写+++++++++++++++++++++++++++++++++++++++++++++++ function（5.1）//调用函数 * 对象指针类名 * 指针名 class Clock ； Clock myclock ； Clock *point；point=&amp;myclock； 运用 point-&gt;showtime(); or (*point).showtime; 注意 1.每个对象初始化之后所占据的空间只是数据成员的空间，并没有函数副本，并且类在未初始化之前并没有分配空间地址，只有实例化之后才分配 2.必须初始化指向已经声明的对象，只可以访问类的公共成员 this指针默认中存在，隐含在每一个类的非静态成员函数中的特殊指针，指向所操作数的对象 例如 在构造函数中 hour=x； 实际上 this-&gt;hour=x; 作用 指出成员函数当前所操作的数据所属的对象，对常成员函数来说，这个this指针就是指向常量的指针（常指针类型） 当局部和外部作用域中有同名的标志符的时候，若想让外部的标志符起作用的时候就可以用this 指向类的非静态成员的指针（只能是公共成员）指向公共函数：(括号) ​ 声明：类型说明符 （类名：：*类成员指针名）（参数表）void (Clock:: *time)(); ​ 赋值：指针名=&amp;类名：：函数成员名 time=&amp;Clock::showtime ​ 访问：对象名.*类成员指针名 或者对象指针名-&gt; *类成员指针名 ​ (myclock. *time)(); 指向公共数据： ​ 声明：类型说明符 类名：：*指针名 例punlic int hour; int Clock :: *hours; ​ 赋值：指针名=&amp;类名：：数据成员名 例 hours=&amp;Clock::hours ​ 访问：对象名.*类成员指针名 或者对象指针名-&gt; *类成员指针名 myclock.hours 指向静态的类成员的指针指针无需特别定义，与一般指针是一致的 动态申请内存操作符new声明：指针=new 数据类型名 T（初始化参数列表）返回指针 ​ 例如：int *point; point=new int()括号可以不写就不初始化，如果括号内没有数据就是默认初始化为0 注意：如果new的是类的对象，就是调用构造函数，如果调用的是相同的默认的构造函数，还会递归地给基本数据类型和和指针类型用0赋初值，用new申请的空间必须由delete进行释放，否则会内存泄漏，而且只能进行一次 指向对象的指针时候：Clock *point=new Clock; delete point; 使用new创建对象数组或一般数组时，不能为该数组指定初始值，其初始值为默认值。 释放内存空间操作delete运算符声明： delete 指针名； 注意：指针只能是由new操作所返回地，如果删除的是对象那么调用析构函数，但是指针本身地址还存在，指针不会被删除 动态创建数组类型声明 ：new 数据类型名[长度] 例 int *point=new int[10];同样可以申请多维 可以在[]之后加()，但是不能写数据进去。 加（）：与上面new对象一致，给每个数据赋值0 不加（）：不对每个数据进行初始化，不赋值 删除: delete[] 指针名 ，如果不写[]那么就只释放首地址 多维：int （*point）[8] [9]=new int[7] [8] [9]可以看成7个[8] [9] vectorvector&lt;类型&gt;名称 +初始化 这个类型不能是引用 浅复制 只是针对类数据成员是动态数组类指针的时候就是直接调用默认的拷贝函数，但是这时候是生成2个指向同一内存地址的指针，所以delete时候会出错 Arrypoint yourpoint（mypoint） 深复制 只是针对类数据成员是动态数组类指针的时候在类写一个拷贝函数，就是再创建一个内存空间 Arryofpoint：：Arryofpoint（const Arryofpoint &amp; v）{size=v.size ，for（）{points【i】=v.points[i]；}}一个个 复制过去 移动构造直接将原对象的内存转移给新对象，而复制构造是再生成一个新空间而将旧空间delete 构造函数参数表（Clock &amp;&amp;n）：points（n.points){ n.points=nullptr} 就是多了将旧指针指向空 string类对象 其实就是string数据类型（引用类型）初始化必须包含string 文件 string（）//建立一个 长度为0的串 string（const char *s）用s所指的字符串常量初始化string string=“ ” 同样可以进行bool 加减 运算 &gt; &lt; != getline string文件getline（cin，s1，“结束标志符”） 继承与多态多态多态行为基础：基类声明虚函数，派生类声明同名函数覆盖这个虚函数 需要函数签名（函数名 参数列表 const）完全一致 继承方式默认是私有继承 共有继承： ​ 继承的访问权限：对基类的private 不可直接访问，这时基类的private继承下来已经发生变化（没有名称的类型） ​ 访问权限：派生类的成员函数可以直接访问基类的public和protected，如果要访问基类的私有成员需要借助基类的共有函数成员，protected成员在类中本来是与private相同，当是在派生类中就变成了public，private同样不能直接访问 私有继承： ​ 基类的全在私有成员中，要访问基类的私有成员，就得从派生类的函数调用基类的函数（这个基类函数是访问基类自己的私有成员） 保护继承： ​ 在派生类中与public一致，在类外时候通过派生类对象不能访问基类任何成员（公有成员也无法直接访问） 多继承class 派生类名：继承方式 基类，继承方式 基类，继承方式 基类{ 成员 } 派生类的构造函数派生类名：：派生类名（形参表）：基类1（参数），基类2（参数）本类成员初始化列表{//其他初始化} 执行顺序按照继承的顺序，而不是按照构造函数上一行所写的数据 派生类的复制构造函数如果没有调用默认，先调用基类的复制构造函数再进行对新成员进行初始化 C：：C（const C &amp;C1）：B（c1）{ } 默认的构造函数是直接将值复制完毕的，如果自己写的话不能是空定义 派生类的析构函数先调用派生类的析构后调用基类的，与构造函数顺序相反，无需显式调用 访问基类被隐藏的成员（与派生类同名的函数）作用域分辨符：：只有在相同的作用域才可以函数重载，所以当派生类中声明了与基类同名的即使参数列表不同，从基类继承的同名函数也会被隐藏，这时要访问就得要用作用域分辨符 可以Clocks.Clock::showtime 类名限定 如果想要将基类的同名函数重载，那么就得用子类中using A:: showtime(int x) 例如Class Clocks: public Clock{public: using Clock::showtime(int x); void showtime(int x,int y);} 二义性问题2个基类中存在相同的函数成员，用类名限定，或者在派生类中添加同名函数再用类名限定 虚基类只有最远派生类调用，解决派生类从多个基类派生，而多个基类又存在同一基类，这时明显这个成员意义是单一的 必须要在一级继承的时候就添加 virtual关键词 例如2级继承爷父儿时候，必须要在这几个父继承时候添加class Clocks：virtual public Clock； 虚基类的构造函数必须在子类的构造函数初始化中添加爷的构造函数Clock（int x）：Grf（x） 调用构造函数顺序，如果有虚基类就先调用虚基类，然后按照类声明顺序 多态的实现静态绑定：绑定在编译连接阶段完成：重载，强制，和参数多态（模板类） 动态绑定：绑定在程序运行阶段完成：包含多态（大多虚函数实现） 运算符重载为成员函数 &lt;代码2&gt;运算符重载的实质是函数重载，只针对同一类的对象 oprd1 和oprd2 都是A类 ，双目运算符+ 如果要实现oprd1+oprd2 则应该在A类中添加运算符重载 oprd1.operator +（oprd2） 参数个数等于原操作数个数-1 单目运算符 前置时候oprd.opeator ++()里面为空 后置oprd.opeator ++(int )这个int 没有用只是用来区分前置和后置 代码：在public中A operator+(const A&amp; c)const;声明 类外A A::operator+(const A&amp; c)const {return A(real + c.real, image + c.image);}创建一个空对象并且返回A类的值(A类型可以返回是* this指针) 运算符重载为非成员函数 &lt;代码3&gt;当是无法被修改的类的2个对象进行运算时候，例如对cout进行输出修改不仅仅是输出int float型，变成可以输出A类的数据时候就需要把重载运算符为非成员函数，参数个数等于操作数个数 双目代码： 最好在类中设置为friend A operator +(const A&amp; c1, const A&amp; c2) 比较好访问数据，类外A operator +(const A&amp; c1, const A&amp; c2) 定义 单目代码：前置operator U （oprd）后置 operator U （oprd ，int）必须多一个没有用的int形参 虚函数本质上是原本函数定义形参时候就需要确定对象，但是虚函数告诉他等最后再确定对象，覆盖掉基类的虚同名函数 虚函数应该属于对象的，不内联,实现动态绑定 目的是爷父儿中存在同名的函数，只写一个形参是三者之一的函数来访问这个同名函数需要解决的问题&lt;代码4&gt;可以只在最老的基类中‘添加virtual，派生类中就不显式地使用virtual 声明虚函数，系统判断是否与基类虚函数名称，参数，返回值来判断，习惯都加virtual增加可读，虚函数会隐藏基类地所有同名重载函数只能通过类名访问 虚析构函数与代码4基本一致，父子关系，想只通过一个带父指针参数地函数来删除一个用new出来地B *b =new C()的指针b 函数void fun（B *b）delete b ；这时只调用B类的析构函数同样得在析构函数加virtual使得BC2个的析构函数都可以调用 虚表 pictureSnipaste_2020-04-09_17-31-09.png vptr指针指向虚表，每个类中都有虚表 抽象类&lt;代码5&gt;带有纯虚函数（暂时无法实现的函数）的类就叫抽象类，抽象类只做基类不能有自己的对象，目的是保证让派生类（自己实现具体功能）具有要求的行为，但是类的指针是可以作为形参的 纯虚函数：virtual 类型 函数名（参数表）=0； c++11 override和finaloverride：当想通过派生类的函数去覆盖基类的虚函数，却因为函数签名不太一致例如少了const，而导致无法覆盖，这种错误往往不好找到，就在派生类需要覆盖的虚函数后面加override声明 例如 void show（）override final： 不允许被继承，成员被覆盖 pictureSnipaste_2020-04-09_17-51-35.png 模板函数模板template &lt; class或typename 名T&gt; 函数（T 形参名） ： void f（T x）； 函数上面必须有template&lt; &gt; 调用f(y)如果y为int就将T变成int类型 ，double同 类模板 例题借鉴&lt;代码6&gt;基本与函数模板一致，使用时候：类名&lt;类型&gt; 对象例如：Clock&lt; int&gt; myclock,yourclock; 大点的动态数组类 代码编号1在类的构造函数中point=new Point[size]完成对这个数组类的创建 未解决静态数据常数据 静态常数据 是否类内可以赋值，以及赋值关系 #define 放在双目计算的中间 闰年计算 清华c++p17 代码6","raw":null,"content":null,"categories":[{"name":"语言基础知识","slug":"语言基础知识","permalink":"www.yundingzhishang.xyz/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"www.yundingzhishang.xyz/tags/C/"}]},{"title":"线性结构4 Pop Sequence","slug":"线性结构4-Pop-Sequence","date":"2020-04-15T14:10:17.000Z","updated":"2020-04-15T14:35:44.922Z","comments":true,"path":"2020/04/15/线性结构4-Pop-Sequence/","link":"","permalink":"www.yundingzhishang.xyz/2020/04/15/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-Pop-Sequence/","excerpt":"","text":"题目 Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.Input Specification:Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.Output Specification:For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.Sample Input:5 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2Sample Output:YESNONOYESNO 题目大意大意就是 给从1到N的长度数据，然后用一个M大小的栈来存放，判断是否可以输出sample中所给的顺序注意：这里的栈刚刚开始只放小于M的任意数量，其余的数可以选择放入或者暂时不放入；例如 测试用例中所给的 1 2 3 4 5 6 7 就可以刚刚开始只给栈中放1个数据（1&lt;5)然后取出来，接着放2，以此类推。 5 6 4 3 7 2 1： 1 2 3 4 5压入栈中，先Pop5 输出，再Push 6 ，接着Pop 6 再Pop 4 3 再Push 7 再Pop 2 1 #include #include #define MAXSIZE 1001 #define LEN ((MAXSIZE + 1) * sizeof(int)) typedef struct QStack* Stack; struct QStack { int Data[MAXSIZE]; int top;//栈顶“指针” }; int main() { int N, M, K; int arry[MAXSIZE];//用来存放遍历元素 scanf(\"%d%d%d\", &M, &N, &K); //M Stack最大，N 长度，K 行数 while (K--) { int x=1, temp = 1; Stack p = (Stack)malloc(LEN); p->top = 1; p->Data[p->top] = 1;//先只在栈中放一个元素 for (int x = 1; x top > M || arry[x] Data[p->top]) // 如果栈溢出 或者 遍历的元素比栈顶元素还小 就break break; if (arry[x] == p->Data[p->top]) { p->top--; x++; } else p->Data[++p->top] = ++temp;//如果没有找到就往栈中再加元素 } if (x == N + 1) printf(\"YES\\n\"); else printf(\"NO\\n\"); } return 0; } 思路我们所能操作的数（与遍历元素比较的数）只有栈顶元素与遍历元素，关键就是观察出栈顶元素与遍历元素，观察出所遍历的元素必定是等于栈顶元素或者是未入栈的元素，由于递增数列这时便有栈顶元素必定小于未入栈元素，–&gt;所遍历的元素大小必须是大于或者等于栈顶元素 总结1.分析题目中所能操作的数（关键数）这题中便是栈顶2.可以借鉴x==N+1来取代flag 判断是否每次循环都是“真” Time2020 4 15 22：33 今天这题花了好久时间才弄清题目，今天有点梦游，加油！！！路漫漫其修远兮，吾将上下而求索。","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"栈","slug":"栈","permalink":"www.yundingzhishang.xyz/tags/%E6%A0%88/"}]},{"title":"栈的四则运算","slug":"栈的四则运算","date":"2020-04-14T13:27:40.000Z","updated":"2020-04-14T14:36:57.948Z","comments":true,"path":"2020/04/14/栈的四则运算/","link":"","permalink":"www.yundingzhishang.xyz/2020/04/14/%E6%A0%88%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/","excerpt":"","text":"中缀转后缀的数组&amp;&amp;直接输出 #include #include #include #include // 包含bool函数 #define MAXSIZE 1000 typedef char ElementType; typedef struct DStack* Stack; struct DStack { int Top; ElementType Data[MAXSIZE];//用数组的顺序堆栈 } S; //Top初始化问题 bool Priority(char a, char b) { // b==* or / //if a>b return true if (a == '*'||a=='/') return true; else return false; } //转换成中缀并且输出 void Change(ElementType* str, Stack p) { int i = 0; p = (Stack)malloc(sizeof(int) + sizeof(ElementType) * MAXSIZE); //结构体定义时候并没有为他分配空间只是告诉系统如何表示数据 p->Top = -1; while (str[i] != '#') { if (str[i] == 32) continue; if (str[i] >= '0' && str[i] Data[++p->Top] = '('; else if (str[i] == ')') { while (p->Data[p->Top] != '(') printf(\"%c\", p->Data[p->Top--]); p->Top--; } else if (str[i] == '+' || str[i] == '-') { while (p->Top != -1 && p->Data[p->Top] != '(') //短路原理p->Top!=-1一定要写在前面 printf(\"%c\", p->Data[p->Top--]); p->Data[++p->Top] = str[i]; //push after pop } else // * or / { while (p->Top != -1 && Priority(p->Data[p->Top], str[i])) printf(\"%c\", p->Data[p->Top--]); p->Data[++p->Top] = str[i]; } i++; } while (p->Top != -1) printf(\"%c\", p->Data[p->Top--]); } int main() { ElementType str[10000]; gets(str); Stack p=NULL; Change(str, p); return 0; } 个位数的四则运算完整 #include #include #include #include // 包含bool函数 #define MAXSIZE 1000 #define LEN (sizeof(int) + sizeof(ElementType) * MAXSIZE) //直接宏定义 typedef char ElementType; typedef struct DStack *Stack; struct DStack { int Top; ElementType Data[MAXSIZE]; //用数组的顺序堆栈 } S; //Top初始化问题 bool Priority(char a, char b) { // b==* or / //if a>b return true if (a == '*' || a == '/') return true; else return false; } //转换成中缀并且输出 void Change(ElementType *str, Stack p, int *Size, ElementType strs[]) { int i = 0; p = (Stack)malloc(LEN); //结构体定义时候并没有为他分配空间只是告诉系统如何表示数据 p->Top = -1; while (str[i] != '#') { if (str[i] == 32) continue; if (str[i] >= '0' && str[i] Data[++p->Top] = '('; else if (str[i] == ')') { while (p->Data[p->Top] != '(') //printf(\"%c\", p->Data[p->Top--]); strs[(*Size)++] = p->Data[p->Top--]; p->Top--; } else if (str[i] == '+' || str[i] == '-') { while (p->Top != -1 && p->Data[p->Top] != '(') //短路原理p->Top!=-1一定要写在前面 strs[(*Size)++] = p->Data[p->Top--]; p->Data[++p->Top] = str[i]; //push after pop } else // * or / { while (p->Top != -1 && Priority(p->Data[p->Top], str[i])) strs[(*Size)++] = p->Data[p->Top--]; p->Data[++p->Top] = str[i]; } i++; } while (p->Top != -1) strs[(*Size)++] = p->Data[p->Top--]; strs[*Size] = '\\0'; } void Out(int Size, ElementType strs[]) //后缀表达式计算,只是个位数的乘法结果也必须是个位数 { int i = 0, temp = 0; Stack p = (Stack)malloc(LEN); p->Top = -1; while (i = '0' && strs[i] Data[++p->Top] = strs[i]; else { switch (strs[i]) { case '+': temp = p->Data[p->Top] + p->Data[p->Top - 1]-'0'-'0'; break; case '-': temp = p->Data[p->Top] - p->Data[p->Top - 1]; break; case '*': temp = (p->Data[p->Top]-'0') * (p->Data[p->Top - 1]-'0'); break; case '/': temp = (p->Data[p->Top--]-'0') / (p->Data[p->Top - 1]-'0'); break; } p->Top--; p->Data[p->Top] = temp+48; } i++; } printf(\"%d\",p->Data[p->Top]-'0'); } int main() { ElementType str[10000], strs[10000]; int Size = 0; gets(str); Stack p = NULL; Change(str, p, &Size, strs); printf(\"%s\\n\", strs); Out(Size,strs); return 0; } 总结中缀转后缀： 1.空栈直接压入 2.只有优先级比栈顶高的才可以压入，如果优先级比栈顶低或者等于，将栈顶一直弹出直到遇见左括号或者栈底 3.遇见右括号时，将栈一直弹出知道遇见左括号 个位数的四则运算： 1.从左往右遇见数字就Push，遇见字符就Pop出栈顶的头2数进行运算把结果再放入栈顶 Time2020 4 14 22:36go up!!! keep up!!!","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"栈","slug":"栈","permalink":"www.yundingzhishang.xyz/tags/%E6%A0%88/"}]},{"title":"vscode配置环境","slug":"vscode配置环境","date":"2020-04-14T08:40:00.000Z","updated":"2020-04-15T05:19:41.434Z","comments":true,"path":"2020/04/14/vscode配置环境/","link":"","permalink":"www.yundingzhishang.xyz/2020/04/14/vscode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/","excerpt":"","text":"c/c++ 环境配置1.vscode 下载c/c++ 插件2. Mingw64（https://sourceforge.net/projects/mingw-w64/files/） 下载安装（直接下载seh结尾的离线直接解压即可）如果要下载在线安装包就得管理员权限运行再科学上网，最后在windows的搜索栏中Mingw64 Install 打开科学上网的下载gcc gdb bin 文件 gcc bin文件和 g++ bin 文件下载安装3.我的电脑属性–高级系统设置–高级–环境变量–系统变量–PATH–新建–Mingw64的bin目录例如D:/profession/Mingw64/bin4.vscode中新建一个路径只有英文也不要有空格的文件夹 .vscode 里面加一个.c文件，随便写一串代码 左边虫子 或者 ctrl shift d 再f5 配置任务选C/C++: gcc.exe build active file5.会自动生成launch.json tasks.json 注意 launch.json miDebuggerPath 不要错 launch .json 配置文件 { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", \"preLaunchTask\": \"build\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false,//这个控制台，true就打开控制台 \"MIMode\": \"gdb\", \"miDebuggerPath\": \"D:/profession//mingw64/bin/gdb.exe\", // 这里修改GDB路径为安装的mingw64的bin下的gdb.exe路径 \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ] }] } tasks.json文件 { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"echo\": true, \"reveal\": \"always\", \"focus\": false, \"panel\": \"shared\" }, \"windows\": { \"command\": \"g++\", \"args\": [ \"-ggdb\", \"\\\"${file}\\\"\", \"--std=c++11\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\\\"\" ] } } ] }","raw":null,"content":null,"categories":[{"name":"软件相关","slug":"软件相关","permalink":"www.yundingzhishang.xyz/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"www.yundingzhishang.xyz/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Zcis的计划","slug":"Zcis的计划","date":"2020-03-29T12:45:42.000Z","updated":"2020-03-29T12:47:22.912Z","comments":true,"path":"2020/03/29/Zcis的计划/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/29/Zcis%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"","text":"html css 基础入门结束2020.3.24 3.25–4.25c++基础语法 和数构的学到5结束10分钟英语物理和数学跟上就好了计算机基础听，c++划掉周五晚做一个项目看看github上源码 –8.25 英语4级 数构结束，javascript结束c++结束 leetcode有一定量了 计网快结束 ，服务器部署ok 学一本linuxshell ，写一个比较理想的网页 Bashshell php或者/python，框架初步学习了解一个 待：计网 刷题 JavaScript 英语听力 数构 框架 计算机系统 linux简单 赛：CSP PAT 综合再看一下超算","raw":null,"content":null,"categories":[{"name":"way","slug":"way","permalink":"www.yundingzhishang.xyz/categories/way/"}],"tags":[{"name":"way","slug":"way","permalink":"www.yundingzhishang.xyz/tags/way/"}]},{"title":"多项式相乘与相加  ","slug":"多项式相乘与相加","date":"2020-03-29T12:35:22.000Z","updated":"2020-04-01T02:22:05.305Z","comments":true,"path":"2020/03/29/多项式相乘与相加/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/29/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E4%B9%98%E4%B8%8E%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"02-线性结构2 一元多项式的乘法与加法运算 (20分)设计函数分别求两个一元多项式的乘积与和。输入格式:输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。输出格式:输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。输入样例:4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1样例:15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 #include #include typedef int Elementtype; typedef struct Node* Listnode;//链表节点 typedef struct Node* Headnode;//头节点 typedef struct Node{ Elementtype Coefficient;//系数 Elementtype Exponent;//指数 struct Node* Next; }Node; Headnode Creat(Elementtype n)//创头节点 { Headnode head; Listnode p, q; q = p = head = (Headnode)malloc(sizeof(Node)); head->Next = NULL; while (n--) { p = (Listnode)malloc(sizeof(Node)); scanf(\"%d%d\", &p->Coefficient, &p->Exponent); //尾插 q->Next = p; q = p; } q->Next = NULL; return head; } Headnode Sum_List(Headnode list_f, Headnode list_s) { Headnode Sum_head, hf, hs; Listnode rear, p; Elementtype temp; hf = list_f->Next;//带头节点的链表头部不放数据 hs = list_s->Next; rear = Sum_head = Creat(0); //使用子函数 while (hf && hs) { if (hs != NULL && hf != NULL) { if (hf->Exponent > hs->Exponent) { p = (Headnode)malloc(sizeof(Node)); p->Exponent = hf->Exponent; p->Coefficient = hf->Coefficient; rear->Next = p; rear = p; hf = hf->Next; } else if (hf->Exponent Exponent) { p = (Headnode)malloc(sizeof(Node)); p->Exponent = hs->Exponent; p->Coefficient = hs->Coefficient; rear->Next = p; rear = p; hs = hs->Next; } else { p = (Headnode)malloc(sizeof(Node)); if (temp = hf->Coefficient + hs->Coefficient) {//temp用于存放系数，如果系数为0的话就跳过 p->Exponent = hf->Exponent; p->Coefficient = temp; rear->Next = p; rear = p; } hf = hf->Next; hs = hs->Next; } } } rear->Next = NULL; if (hs) rear->Next = hs;//直接指向hs，千万别再创链表 if (hf) rear->Next = hf; return Sum_head; } Headnode Mult_List(Headnode list_f, Headnode list_s) {//乘法的话多次利用加法，因为列a中的数乘于列b，那么这个数列必定是有序的 Headnode Mult_head, Z_head, hf, hs; Listnode rear, p; hf = list_f->Next; hs = list_s->Next; Mult_head = (Headnode)malloc(sizeof(Node)); Mult_head->Next = NULL;//用于存放乘法结果 if (hf && hs) { while (hf) { rear = Z_head = (Headnode)malloc(sizeof(Node)); //用于存放列a的某个数乘以列b所得到的新数列 Z_head->Next = NULL; while (hs) { p = (Headnode)malloc(sizeof(Node)); p->Exponent = hf->Exponent + hs->Exponent; p->Coefficient = hf->Coefficient * hs->Coefficient; rear->Next = p; rear = p; hs = hs->Next; } hs = list_s->Next; hf = hf->Next; rear->Next = NULL;//NULL一定要补，要不导致Mult没有结尾 Mult_head = Sum_List(Mult_head, Z_head); //需要给Mult_head这个链表结尾NULL } } return Mult_head; } void PrintList(Headnode L) { Elementtype f = 0; Headnode p = L->Next; if (!p)//全0的数列 printf(\"0 0\"); else while (p) { //可以借鉴下这个第一个数不输入空格的方法 if (f) printf(\" \"); else f = 1; printf(\"%d %d\", p->Coefficient, p->Exponent); p = p->Next; } } int main() { Headnode Sum_head, Mult_head; Listnode List_f, List_s; Elementtype n; scanf(\"%d\", &n); List_f = Creat(n); scanf(\"%d\", &n); List_s = Creat(n); PrintList(Mult_List(List_f, List_s)); printf(\"\\n\"); PrintList(Sum_List(List_f, List_s)); return 0; } 总结1.这道题虽然思路并不复杂，但是操作确实需要对链表足够熟练2.解题的难点是乘法，我们如果暴力直接得到新乘法链表，那么是无序的非常麻烦，所以我们需要考虑构造出有序的小链表，因为题目所给的是有序指数链表，所以得到一个指数必定是有序的3.同样可以用桶排序来做","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"www.yundingzhishang.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":" 两个有序链表序列的合并","slug":"两个有序链表序列的合并","date":"2020-03-09T08:41:20.000Z","updated":"2020-03-09T08:54:20.379Z","comments":true,"path":"2020/03/09/两个有序链表序列的合并/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/09/%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/","excerpt":"","text":"本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。函数接口定义：List Merge( List L1, List L2 );其中List结构定义如下：typedef struct Node PtrToNode;struct Node { ElementType Data; / 存储结点数据 / PtrToNode Next; / 指向下一个结点的指针 /};typedef PtrToNode List; / 定义单链表类型 */ List Merge( List L1, List L2 ) { //头节点不存放数据 List head,p; //空链表是头节点存在但是next是NULL p=head=(List)malloc(sizeof(struct Node)); List a=L1->Next; List b=L2->Next; while(a&&b) //不要再写(a!=NULL&&b!=NULL)了 { if(a->DataData) { p->Next=a; a=a->Next; } else { p->Next=b; b=b->Next; } p=p->Next; } p->Next=a?a:b; //若a不为NULL，就直接将a剩下的接上去，b同理 L1->Next=NULL; L2->Next=NULL; return head; } 总结1.以后链表合并千万别自己再创建链表，可以直接接上去2.要将a&amp;&amp;b 来替换原来的 a！=NULL&amp;&amp;3. 头节点是不存放数据，空链表是head存在但是head-&gt;Next=NULL","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"链表合并","slug":"链表合并","permalink":"www.yundingzhishang.xyz/tags/%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/"}]},{"title":"算法精简题","slug":"算法精简题","date":"2020-03-09T01:31:41.000Z","updated":"2020-04-14T14:35:00.773Z","comments":true,"path":"2020/03/09/算法精简题/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/09/%E7%AE%97%E6%B3%95%E7%B2%BE%E7%AE%80%E9%A2%98/","excerpt":"","text":"做最大水桶 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。","raw":null,"content":null,"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"www.yundingzhishang.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"洗牌","slug":"洗牌","date":"2020-03-06T14:00:39.000Z","updated":"2020-03-06T14:34:13.673Z","comments":true,"path":"2020/03/06/洗牌/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/06/%E6%B4%97%E7%89%8C/","excerpt":"","text":"Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:S1, S2, , S13,H1, H2, , H13,C1, C2, , C13,D1, D2, , D13,J1, J2where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.Output Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.Sample Input:236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47Sample Output:S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5 #include #include int main() { int n = 0, t = 0; scanf(\"%d\", &n); char str[55][4], strs[55][4];//2个数组，一个用来临时存放 for (int x = 1; x 0)str[x][1] = x % 13 + 48; if (x % 13 >= 10) { str[x][1] = '1'; str[x][2] = x % 13 + 48 - 10; } if (x % 13 == 0) { str[x][1] = '1'; str[x][2] = '3'; } switch (t) { case 0: str[x][0] = 'S'; break; case 1: str[x][0] = 'H'; break; case 2: str[x][0] = 'C'; break; case 3: str[x][0] = 'D'; break; } } strcpy(str[53], \"J1\"); strcpy(str[54], \"J2\"); int arry[55]; for (int x = 1; x 题目分析题目难点主要是1.创建这个扑克的数组2.洗牌次数 总结和反思1.创建这个扑克牌所写的太长，可以 用c++的string类型，直接手动数组输入2.将str更新，而不是将str和strs交替互相更新（洗一次放入str，再洗一次放入strs，巨麻烦）3.输出最后一个数没有空格，直接跳出循环，不要用if(y!=54)了","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"www.yundingzhishang.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"字符串处理","slug":"字符串处理","date":"2020-03-05T08:07:23.000Z","updated":"2020-03-09T08:57:56.494Z","comments":true,"path":"2020/03/05/字符串处理/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"大位数乘法乘法 Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.Input Specification:Each input contains one test case. Each case contains one positive integer with no more than 20 digits.Output Specification:For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.Sample Input: 1234567899Sample Output: Yes\\n2469135798 #include #include #include char doubleit(char str[], int x); bool ist(char str[], int length); char ch = 32;//创建一个可能多出一位的最大的位数的数 bool ist(char str[],int last)//是否两者的数都互有涵盖 { int arry[10] = { 0 }, arrys[10] = { 0 };//记得桶排 for (int x = 0; x =0 ; x--)//开始乘法 { temp = (str[x] - 48) * 2 ;//取模 str[x] = temp%10 + 48+lastone; lastone = temp / 10; if (x == 0 && lastone != 0) ch = lastone + 48; } return ch; } int main() { char str[22]; int lastnumber; scanf(\"%s\", str);//scanf会自动补'\\0' lastnumber = strlen(str)-1;//strlen不包括'\\0' if (ist(str, lastnumber))printf(\"Yes\\n\"); else printf(\"No\\n\"); if (ch != 32) printf(\"%c%s\", ch, str); else printf(\"%s\", str); return 0; } 总结大数据做运算用字符串来存放，注意的点1.数据是“倒序存放”，这时就一定注意可能多出来一位，需要再构建一位2.进位问题，有可能是1也有可能是2，所以用取模的方法就较为简单3.若有对比问题，flag或者memset都要想到4.同样可以建多数组，将计算结果直接存放在新数列","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"www.yundingzhishang.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"记一道数组循环移动的反思","slug":"记一道数组循环移动的反思","date":"2020-03-04T08:20:03.000Z","updated":"2020-03-06T14:33:45.027Z","comments":true,"path":"2020/03/04/记一道数组循环移动的反思/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/04/%E8%AE%B0%E4%B8%80%E9%81%93%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%8F%8D%E6%80%9D/","excerpt":"","text":"一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。输入样例:6 21 2 3 4 5 6输出样例:5 6 1 2 3 4 注意此题N与M大小关系都有可能存在 常规思维 #include int main() { int N, M; scanf(\"%d %d\", &N, &M); int arry[101]; for (int x=1; x = N)M -= N;//M是有可能大于N的 for (int x = N - M + 1; x 总结通过改变输出的方式，“伪” 改成数组右移 动态数组 #include #include int main(){ int N, M, * arry; scanf(“%d %d”, &amp;N, &amp;M); arry = (int*)malloc((N + 1) * sizeof(int)); M = M % N; for (int x = M + 1; x &lt;= N; x++) scanf(“%d”, &amp;arry[x]); for (int x = 1; x &lt;= M; x++) scanf(“%d”, &amp;arry[x]); for (int x = 1; x &lt;= N; x++) { if (x != N)printf(“%d “, arry[x]); else printf(“%d”, arry[x]); } return 0;} 总结这个做法主要突出动态数组来创建数组和非常规的输入完成所需要的输出和取模操作来确定实际的移动","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"反思","slug":"反思","permalink":"www.yundingzhishang.xyz/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"素数有关猜想猜想","slug":"素数有关猜想猜想","date":"2020-03-03T11:34:11.000Z","updated":"2020-03-03T11:41:07.792Z","comments":true,"path":"2020/03/03/素数有关猜想猜想/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/03/%E7%B4%A0%E6%95%B0%E6%9C%89%E5%85%B3%E7%8C%9C%E6%83%B3%E7%8C%9C%E6%83%B3/","excerpt":"","text":"让我们定义dn为：dn=n+1−pn，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N(&lt;105次方)，请计算不超过N的满足猜想的素数对的个数。输入格式:输入在一行给出正整数N。输出格式:在一行中输出不超过N的满足猜想的素数对的个数。输入样例:20输出样例:4 #include #include #include bool iss(int x){ int n = 2,flag=1; for (; n &lt;= sqrt(x); n++) if (x % n == 0)flag = 0; if (flag == 1)return 1; else return 0;} int main(){ int n; scanf(“%d”, &amp;n); int x = 1,sum=0; int x1 = 2,x2; for (x = 2; x &lt;= n; x++) { x2 = x1; if (iss(x))x1 = x; if (x1 - x2 == 2)sum++; } printf(“%d”, sum); return 0;}.h文件，bool属于c++的范畴里判断素数的方法熟记 ,同时bool需要有stdbool.h文件，bool属于c++的范畴里","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"素数","slug":"素数","permalink":"www.yundingzhishang.xyz/tags/%E7%B4%A0%E6%95%B0/"}]},{"title":"打印图形题","slug":"记打印图像水题反思","date":"2020-03-01T05:03:16.000Z","updated":"2020-03-03T09:24:57.372Z","comments":true,"path":"2020/03/01/记打印图像水题反思/","link":"","permalink":"www.yundingzhishang.xyz/2020/03/01/%E8%AE%B0%E6%89%93%E5%8D%B0%E5%9B%BE%E5%83%8F%E6%B0%B4%E9%A2%98%E5%8F%8D%E6%80%9D/","excerpt":"","text":"沙漏类型题 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 ***** *** * *** ***** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。输入样例:19 *输出样例: ***** *** * *** ***** 2 #include #include int main() { int N; char ch; scanf(\"%d %c\", &N, &ch); int k = sqrt((N + 1) / 2); int Number = k, SPACE=0; int space=0, charnumber,x; for (; k >= 1; k--,space++) { for (x = 0; x 注意结尾记得把多余的k--与space++还回来 k += 2; space-=2; for (; k 该题主要需要寻找行与需打印空格和符号的数量之间的关系图形题主要就是找行与特殊符号之间的关系而这道题用奇数来打印特殊符号即得出以下特殊规律（记忆）从1开始的奇数项的和等于该奇数数目的平方即1+3+……+(2n+1)=n*n 杨辉三角 【输入形式】从键盘输入整数n（n&gt;=0且n&lt;=12）【输出形式】在屏幕上输出n+1行杨辉三角形。【输入样例】3【输出样例】------***1----***1***1--***1***2***1***1***3***3***1其中－和*都是空格位即每个数字占四位！ #include int main() { int n; scanf(\"%d\", &n); int arry[14][14] = { 0 }; int x, y,space; for (x = 1; x 2 * (n - x); space++) printf(\" \"); for (y = 1; y 同样杨辉三角主要是考虑前面空格数和行数的关系这题就可以用“倒”数的方法来进行行的计算","raw":null,"content":null,"categories":[{"name":"基础题型总结","slug":"基础题型总结","permalink":"www.yundingzhishang.xyz/categories/%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"打印图像","slug":"打印图像","permalink":"www.yundingzhishang.xyz/tags/%E6%89%93%E5%8D%B0%E5%9B%BE%E5%83%8F/"}]},{"title":"c内存指针","slug":"c内存指针","date":"2020-02-29T12:51:39.000Z","updated":"2020-04-01T02:21:17.996Z","comments":true,"path":"2020/02/29/c内存指针/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/c%E5%86%85%E5%AD%98%E6%8C%87%E9%92%88/","excerpt":"","text":"指针在子母函数作为参数的传输总结1.本质上是在子函数中创建一个新指针指向这个变量，所以在子函数中只能修改变量的值，而不能修改实参指针所指向的变量2.链表中是一样的，如果想在子函数中创建一个新链表必须返回头节点，但是如果只是想修改链表中的值，或者逆转链表，在子函数直接进行即可（在子函数中将头节点指向另外的节点无需返回值就可以逆转链表了） &lt; Document &lt;style&gt; div { background-color: pink; width: 100px; height: 200px; } &lt;/style&gt; 时间2020 4 1","raw":null,"content":null,"categories":[{"name":"C内存指针","slug":"C内存指针","permalink":"www.yundingzhishang.xyz/categories/C%E5%86%85%E5%AD%98%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C","slug":"C","permalink":"www.yundingzhishang.xyz/tags/C/"}]},{"title":"堆栈的链表创建","slug":"堆栈的链表操作","date":"2020-02-29T12:48:21.000Z","updated":"2020-02-29T12:58:42.416Z","comments":true,"path":"2020/02/29/堆栈的链表操作/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"#include #include typedef struct SNode* Snode; typedef int ElementType;//易于修改提高精度或者程序可读性 typedef struct SNode { ElementType data; Snode next; }; Snode CreateStack( ){ Snode p; p = (Snode)malloc(sizeof( SNode)); p-&gt;next = NULL; return p;} bool Push(Snode p, ElementType x)//注意用bool{//放入数据 Snode q; q = (Snode)malloc(sizeof(SNode)); q-&gt;data = x; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;} ElementType Pop(Snode p)//判断是否空或者满（不再赘述）{//这个p是一个没有数据的头节点 //取数 //这时的p其实是把地址传送到子函数，这时的p也就是母函数中的p ElementType x= p-&gt;data; Snode q=p-&gt;next;//注意此时的p-&gt;next 发生变化而p未发生变化 p-&gt;next = q-&gt;next; free(p); return x;}","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"堆栈的动态数组创建","slug":"堆栈的动态数组创建","date":"2020-02-29T03:17:35.000Z","updated":"2020-02-29T03:22:30.088Z","comments":true,"path":"2020/02/29/堆栈的动态数组创建/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/29/%E5%A0%86%E6%A0%88%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"#include #include typedef int Position; typedef struct SNode { Position* arry;//动态数组 Position Maxsize;//最大值 Position tag;//数组的下标 Position data;//该数据 }Snode; Snode* Creat(Position Maxsize)//创建这个堆栈 { Snode* p; p = (Snode*)malloc(sizeof(Snode));//来一个指针指向这个结构体 p->arry = (int*)malloc(Maxsize * sizeof(Position));//创建动态数组的数据 //p->arry[n]=x;可以在此赋值 p->Maxsize = Maxsize; p->tag = -1; return p; } bool Isfull(Snode* p)//往堆栈放时注意是否满了 { if (p->tag == p->Maxsize - 1) return false; else return true; } bool Isempty(Snode* p)//注意空 { if (p->tag == -1) return -1; else return 1; } Snode* Push(Snode* p,Position X) { if (Isfull) { p->arry[++(p->tag)] = X; } else printf(\"full\"); } int Pop(Snode* p) { if (Isempty(p)) return p->arry[(p->tag)--]; else printf(\"isempty\"); }","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"梦","slug":"梦","date":"2020-02-27T15:16:44.000Z","updated":"2020-02-27T15:38:34.516Z","comments":true,"path":"2020/02/27/梦/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/27/%E6%A2%A6/","excerpt":"","text":"The goal in these three yearsThe first of allEacape the influence of othersFind the happiness of technologyBe myself don’t care about others eyesAbandon something may effect me such as gamesDo more things instead speakingMake less friends but they can get along well with meDuring these days,I may also find a life partnerEnjoy the loneless the goalI can work in big companies such as Tencent and alibaba the time2020-2-27 23 :36 nameZcis","raw":null,"content":null,"categories":[{"name":"dream","slug":"dream","permalink":"www.yundingzhishang.xyz/categories/dream/"}],"tags":[]},{"title":"链表的基本操作","slug":"链表的基本操作","date":"2020-02-27T02:26:44.000Z","updated":"2020-02-27T03:20:15.221Z","comments":true,"path":"2020/02/27/链表的基本操作/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/27/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"链表的基本操作有头节点的尾插单链表先建头节点，头节点没有存放数据，尾插是从左往右需要3个结构指针 #include #include typedef struct Node { int x; struct Node* next; }node; int main() { node* head; node* p; node*q; head = (Node *)malloc(sizeof(node)); head->next = NULL; p = head; int t; for (t = 1; t x); p->next = q; p = q; } p->next = NULL; return 0; } ![尾插法]（https://raw.githubusercontent.com/LINGyue-dot/a-mass-of-photos/master/blog/%E5%B0%BE%E6%8F%92%E6%B3%95.png） 带头指针的头插法从右往左开始输入插入，一样头指针没有存放数据,若要按正序的，一样也需要3个结构指针 #include//head cut #include typedef struct Node { int x; struct node* next; }node; int main() { node* head, * p; head = (node*)malloc(sizeof(node)); head->next = NULL; int t = 0; for (t = 1; t x); p->next = head->next; head->next = p; } while (p != NULL) { printf(\"%d\", p->x); p = p->next; } return 0; } 头插法","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"recursive algorithm","slug":"recursive-algorithm","date":"2020-02-26T09:05:51.000Z","updated":"2020-03-10T03:13:39.059Z","comments":true,"path":"2020/02/26/recursive-algorithm/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/recursive-algorithm/","excerpt":"","text":"递归方法归纳判断是否为递归问题取决于是否每次执行的是相同的工作起到相同的功能例如汉诺塔中的每次n个碟子移动时，总是需要先将n-1个碟子移到中间碟子中可以用一般式n表示该问题 总结1.结束时的条件2.分析一层递归需要实现的功能3.返回值是如何，传送给上一级的信息 汉诺塔 #include using namespace std; void hanoi(int n, char one, char two, char three); //one是原始柱，two是中间柱子，three是结尾柱 void move(char x,char y); void move(char x, char y)//输出 { cout \" 汉诺塔问题分析与总结1.&lt; 判断是否递归&gt;模拟汉诺塔移动，因为大的总在小的下面，所以当最大的碟子放在C上时，n-1个在C上，这时可以忽略这个这个最大的碟子，也就是把问题看成n-1个碟子从B柱子移动到C柱子（A为原始柱，B为中间柱，C为目标柱），所以这个是一个递归问题（每次都需要将n-1个碟子送到中间柱子上）2.&lt; 结束操作与条件&gt;分析n-1的终点是什么？必定是只剩一个碟子（这里可以用极限n=1）3.&lt; 每层执行的功能&gt;即执行从A上移动n-1个碟子到B上，再将A最大碟子移动到C上，再将B上n-1个碟子移到C上 二分法求数组最大子序列 #include #include//malloc using namespace std; int Maxnumber(int x, int y, int z)//判断最大的值 { return x > y ? x > z ? x : z : y > z ? y : z; } int Max(int arry[], int left, int right) { if (left == right) return arry[left]; int center = (left + right)/2; int Tempsum=0,Maxleftsum=0,Maxrightsum=0; //求出从中间点向左右衍生的最大子序列值 for (int x = center; x >= left; x--) { Tempsum += arry[x]; Maxleftsum = Tempsum > Maxleftsum ? Tempsum : Maxleftsum; } Tempsum = 0; for (int x = center + 1; x Maxrightsum ? Tempsum : Maxrightsum; } return Maxnumber(Maxrightsum + Maxleftsum, Max(arry, left, center), Max(arry, center + 1, right)); //只需要比较左边最大值，右边最大值和从中间开始的最大值 } int main() { int* arry, x,Maxsum=0,Tempsum=0; cin >> x; arry = (int*)malloc(x * sizeof(int));//动态数组 for (int y=0; y > arry[y]; Maxsum = Max(arry, 0, x-1); if (Maxsum 总结1.&lt; 是否为递归&gt;每次都进行二分，都是将总的分为2，再从左边最大值和右边最大值还有中间衍生的最大值这3者中取最大值。2.&lt; 结束条件&gt;二分的结果必定是只剩一个3.&lt; 每次实现功能以及返回信息&gt;算出3者大小，返回最大值","raw":null,"content":null,"categories":[{"name":"递归","slug":"递归","permalink":"www.yundingzhishang.xyz/categories/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]},{"title":"浙大数据结构笔记---最大连续子数列","slug":"浙大数据结构笔记-最大连续子数列","date":"2020-02-26T07:51:58.000Z","updated":"2020-03-06T14:34:06.703Z","comments":true,"path":"2020/02/26/浙大数据结构笔记-最大连续子数列/","link":"","permalink":"www.yundingzhishang.xyz/2020/02/26/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97/","excerpt":"","text":"最大连续子数列在线处理法在线处理法 #include int main() { int arry[11]; int x, Maxsum = 0, Thissum = 0; for (x = 0; x Maxsum)Maxsum = Thissum; else if (Thissum 从左往右开始扫描，若现在的Thissum为负数就丢弃，比较大就替代。 分而治之的递归算法 #include int Maxs(int x, int y, int z) { return x > y ? x > z ? x : z : y > z ? y : z; } int Maxsum(int left, int right, int arry[]) { if (left == right) if (arry[right] = left; i--) { sum += arry[i]; if (sum > maxsumleft)maxsumleft = sum; }//先计算从中间线开始左边的最大值 sum = 0; for (i = center + 1; i maxsumright)maxsumright = sum; }//再计算右边最大值注意是连续的 return Maxs(leftsum, rightsum, maxsumleft + maxsumright); } int main() { int arry[101]; int i, j; scanf(\"%d\", &j); for (i = 0; i 大概流程","raw":null,"content":null,"categories":[{"name":"浙大数构笔记","slug":"浙大数构笔记","permalink":"www.yundingzhishang.xyz/categories/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%9E%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数构算法","slug":"数构算法","permalink":"www.yundingzhishang.xyz/tags/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}]}]}